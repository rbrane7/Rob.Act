using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.ComponentModel;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Diagnostics;
using Microsoft.Win32;
using Aid.Extension;
using System.Collections.Specialized;
using System.Globalization;
using Aid.IO;

namespace Rob.Act.Analyze
{
	using Book = Gen.Book ;
	/// <summary>
	/// Interaction logic for MainWindow.xaml
	/// </summary>
	public partial class Main : Window , INotifyPropertyChanged
	{
		public static Settings Setup => setup?.Result ; static readonly Aid.Prog.Setup<Settings> setup ;
		static Main() { new Aid.Prog.Setup(e=>Trace.TraceError($"Setup {e}")).Go() ; setup = (Resetup,e=>Trace.TraceError($"Setup Settings {e}")) ; Doct = (Setup.Doctee.Uri(),e=>Trace.TraceError($"Doctor {e}")) ; }
		static Aid.Prog.Doct Doct ;
		public static readonly Aspect Laboratory = new Aspect() ;
		readonly Presources Presources ;
		static void Resetup( Settings past )
		{
			if( Doct?["Main"] is Main main );else return ;
			if( Setup?.ActionTraits?.Equates(past?.ActionTraits)==false ) main.Dispatcher.Invoke(()=>main.BookGrid_AutoGeneratedColumns(main.BookGrid)) ;
			if( Setup?.SpectrumBinds?.Equates(past?.SpectrumBinds)==false ) main.Book.Each(p=>p.Spectrum.Reform(Setup.SpectrumBinds)) ;
			if( Setup?.SubjectMass.Equates(past?.SubjectMass)==false ) Basis.Mass = Setup.SubjectMass ;
		}
		public State State { get => state ; private set => state = (value??new State()).Set(s=>s.Context=this) ; } State state ;
		FileSystemWatcher[] WorkoutsWatchers ;
		public event PropertyChangedEventHandler PropertyChanged ;
		void PropertyChangedOn<Value>( string properties , Value value ) { PropertyChanged.On(this,properties,value) ; if( properties.Consists("Sources") ) if( GraphTab.IsSelected ) Graph_Draw(this) ; else if( MapTab.IsSelected ) Map_Draw(this) ; }
		public Main()
		{
			InitializeComponent() ; Presources = new Presources(BookGrid,this) ; AppDomain.CurrentDomain.Load(typeof(AxeOperations).Assembly.FullName) ; ViewPanel = GraphPanel ; DataContext = this ;
			Doct += (this,"Main") ; Aspectables.The = ()=>Book.Select(p=>p.Spectrum).Union(Aspects) ; SourcesGrid.ItemContainerGenerator.ItemsChanged += SourcesGrid_ItemsChanged ; Load() ;
		}
		void Load()
		{
			Setup.Altiplane.nil(a=>a.Grade==0).Use(g=>{
				Path.Altiplanes = new List<Path.Altiplane>() ;
				foreach( var a in System.IO.Directory.GetFiles(Setup.StatePath,$"{Altiplane.FileSign}*{Path.Altiplane.ExtSign}") ) { Trace.TraceInformation($"Loading {a}") ; Path.Altiplanes.Add(new Path.Altiplane(a){Radius=g.Radius}) ; }
				if( Path.Altiplanes.Count==0 ) Path.Altiplanes.Add(new Path.Altiplane(g.Grade,g.Grane){Radius=g.Radius}) ;
			}) ;
			Setup.WorkoutsPaths.SeparateTrim(',').SelectMany(l=>l.MatchingFiles()).EachGuard(f=>{Trace.TraceInformation($"Loading {f}");NewAction(f,Setup?.WorkoutsFilter);},(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			Setup.AspectsPaths.SeparateTrim(',').SelectMany(l=>l.MatchingFiles()).EachGuard(f=>{Trace.TraceInformation($"Loading {f}");NewAspect(f,Setup?.AspectsFilter);},(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			WorkoutsWatchers = Setup.WorkoutsPaths.SeparateTrim(',').Select(l=>new FileSystemWatcher(l){EnableRaisingEvents=true}.Set(w=>{ w.Edited += NewAction ; w.Deleted += (s,a)=>Book-=p=>p.Origin==a.FullPath ; })).ToArray() ;
			State = new State{ Context = this } ;
		}
		protected override void OnClosing( CancelEventArgs e ) { Doct?.Dispose() ; base.OnClosing(e) ; }
		protected override void OnClosed( EventArgs e ) { base.OnClosed(e) ; Process.GetCurrentProcess().Kill() ; }
		void NewAction( string file , Predicate<Pathable> filter = null ) => file.Reconcile().Internalize().Set(p=>p.Origin=file).Set(Translation.Partitionate).Set(p=>p.Spectrum.Reform(Setup.SpectrumBinds)).Set(p=>{Book|=(filter as Predicate<Pathable>)?.Invoke(p)!=false?p:null;if(Book.Contains(p)){ActionEnhancing(p,ActiveRefiner);Dispatcher.Invoke(SaveBook);}}) ;
		void NewAction( object subject , System.IO.FileSystemEventArgs arg ) => NewAction(arg.FullPath,Setup?.WorkoutsFilter) ;
		void NewAspect( string file , Predicate<Aspect> filter = null ) => ((Aspect)file.ReadAllText()).Set(a=>a.Origin=file).Set(a=>Aspects+=(filter as Predicate<Aspect>)?.Invoke(a)!=false?a:null) ;
		public Book Book { get ; private set ; } = new Book("Main") ;
		public Filter ActionFilter { get => actionFilter ; internal set { if( value==actionFilter ) return ; actionFilter = value ; PropertyChanged.On(this,"ActionFilter") ; } } Filter actionFilter ;
		public Filter SourceFilter { get => sourceFilter ; internal set { if( value==sourceFilter ) return ; sourceFilter = value ; PropertyChanged.On(this,"SourceFilter") ; } } Filter sourceFilter ;
		public Filter AspectFilter { get => aspectFilter ; internal set { if( value==aspectFilter ) return ; aspectFilter = value ; PropertyChanged.On(this,"AspectFilter") ; } } Filter aspectFilter ;
		string[] ActionTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Traits.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.ActionTraits ;
		string[] MatrixTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Matrix.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.MatrixTraits?.Concat(BookGrid.SelectedItems.OfType<Path>().SelectMany(p=>p.Metax?.Bonds??Enumerable.Empty<string>()).Distinct()).ToArray() ;
		async void ActionFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { Presources.Snapshot() ; using( new Aid.Closure(()=>BlockSourcesUpdate=true,()=>BlockSourcesUpdate=false) ) FilterGrid_SelectionChanged<Pathable,Associable>(sender,a=>{Book.Refinement=a.Select(f=>(f.Filter,f.Query));ActionsEnhancing(a);BookGrid_AutoGeneratedColumns();}) ; await Task.Delay(1) ; Presources.Reselect() ; } internal bool BlockSourcesUpdate ;
		void SourceFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Aspect>(sender,f=>{Sourcer=f;Sources=sources;}) ;
		void AspectFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Aspect>(sender,f=>Aspects.Refinement=f) ;
		void FilterGrid_SelectionChanged<Objective>( object sender , Action<(Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>>)[]> doing ) => (sender as DataGrid)?.SelectedItems.OfType<Filter.Entry>().Select(f=>(f.ToFilter<Objective>(),f.ToQuery<Objective>())).ToArray().Set(doing) ;
		IEnumerable<(Func<Objective,bool> Filter,Func<Enhancer,bool> Associer,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)> Refiner<Objective,Enhancer>( DataGrid sender ) => sender.SelectedItems.OfType<Filter.Entry>().Select(f=>f.ToRefiner<Objective,Enhancer>()) ;
		(Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] ActiveRefiner ; Metax ActiveMetax ;
		void FilterGrid_SelectionChanged<Objective,Enhancer>( object sender , Action<(Func<Objective,bool> Filter,Func<Enhancer,bool> Associer,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)[]> doing ) => Refiner<Objective,Enhancer>(sender as DataGrid).ToArray().Set(r=>ActiveRefiner=r as (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[]).Set(doing) ;
		public Aid.Collections.ObservableList<Aspect>.Filtered Aspects { get ; private set ; } = new Aid.Collections.ObservableList<Aspect>.Filtered{Sensible=true} ;
		void ActionsEnhancing( params (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] refiner ) { ActiveMetax = null ; foreach( var path in Book ) ActionEnhancing(path,refiner) ; Dispatcher.Invoke(SaveBook) ; }
		void ActionEnhancing( Pathable path , params (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] refiner ) { if( refiner==null || path==null ) return ; path.Spectrum.Trait.Clean() ; foreach( var refine in refiner ) if( refine.Filter?.Invoke(path)!=false ) foreach( var asp in Aspects.Entries ) if( (refine.Associer?.Invoke((path,asp))??(refine.Filter!=null?Setup.ActionAssocier?.Invoke(path,asp):false))==true ) new Aspect(asp){Source=path.Spectrum}.Set(a=>{path.Spectrum.Trait.Add(a.Trait);path.Spectrum.Tager+=a.Tager;}) ; PathEnhancing(path as Path) ; }
		void PathEnhancing( Path path ) => path.Set(p=>p.Metax=ActiveMetax??(ActiveMetax=new Metax(p.Metax?.Base??p.Dimension)))?.Populate() ;
		void SaveBook() { if( ActionFilterGrid.SelectedItems.Count==1 && (ActionFilterGrid.SelectedItem as Filter.Entry)?.Matter.Null(v=>v.Void()) is string matter && Book.Count>0 && Setup?.WorkoutsPath is string path ) try{Book.Save(path,matter);}catch(System.Exception e){Trace.TraceError("Save Book failed on {0}:{1} : {2}",path,matter,e);} }

		#region Core
		public Aid.Collections.ObservableList<Axe> Axes { get ; private set ; } = new Aid.Collections.ObservableList<Axe>() ; public bool Multiaspected => Aspect.Any(b=>b.Multi) ;
		/// <summary> Aspect is never null , either Spectrum , or aspect ready for projection . If without selection then set to <see cref="Laboratory"/> . </summary>
		public Aspect Aspect { get => Respect ; protected set { if( (value??Laboratory)==Aspect ) return ; Aspect.Set(a=>{a.CollectionChanged-=OnAspectChanged;a.PropertyChanged-=OnAspectChanged;}) ; (Respect=value??Laboratory).Set(a=>{a.CollectionChanged+=OnAspectChanged;a.PropertyChanged+=OnAspectChanged;}) ; AspectAxisGrid.CanUserAddRows = AspectAxisGrid.CanUserDeleteRows = AspectTraitsGrid.CanUserAddRows = AspectTraitsGrid.CanUserDeleteRows = AspectsGrid.SelectedItems.Count<=1 ; Sources = null ; } } Aspect Respect = Laboratory ;
		public IEnumerable<Aspect> Sources { get => Resources.Issue(Sourcer) ; set => PropertyChangedOn("Aspect,Sources",sources=value) ; } (Func<Aspect,bool> Filter,Func<IEnumerable<Aspect>,IEnumerable<Aspect>> Query)[] Sourcer ;
		new IEnumerable<Aspect> Resources => sources ??( sources = new Aid.Collections.ObservableList<Aspect>(ActionsProjection) ) ; IEnumerable<Aspect> sources ;
		Aspect Projection( Pathable path ) => new Aspect(Aspect){Source=path.Spectrum} ;
		IEnumerable<Aspect> Projection( IEnumerable<Pathable> p ) => p.Select(Projection).ToArray().Each((s,a,i)=>a.Sources=s.Skip(i).Concat(s.Take(i)).ToArray()) ;
		IEnumerable<Aspect> ActionsProjection => Presources.Get( p => Aspect is Path.Aspect ? p.Select(s=>s.Spectrum) : Projection(p) ) ;
		Aspect Resource( Pathable path ) => Aspect is Path.Aspect ? path.Spectrum : Projection(path) ;
		int SourceIndex( object item ) => item is Aspect asp ? Resources.IndexIf(a=>a==asp) is int i ? i : Presources.IndexOf(asp?.Raw) : item is Pathable path ? Resources.IndexIf(a=>a.Raw==path) is int j ? j : Presources.IndexOf(path) : -1 ;
		Color Coloring( object item ) => Coloring(SourceIndex(item)) ;
		#endregion

		void SourcesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => Sources = sources ;
		void AspectTraitsGrid_SelectionChanged( object sender, SelectionChangedEventArgs e ) => new HashSet<string>(AspectTraitsGrid.SelectedItems.OfType<Aspect.Traitlet>().Select(t=>t.Spec)).Set(t=>SourcesGrid.Columns.Skip(1).Each(c=>c.Visibility=t.Contains(c.Header)?Visibility.Hidden:Visibility.Visible)) ;
		void CoordinatesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( MapTab.IsSelected ) Map_Draw(this) ; }
		void OnAspectChanged( object subject , NotifyCollectionChangedEventArgs arg=null ) { var sub = Aspect is Path.Aspect ? SpectrumTabs : AspectTabs ; Revoke : var six = sub.SelectedIndex ; if( sub==AspectTabs || sub==QuantileTabs ) Sources = null ; sub.SelectedIndex = -1 ; sub.SelectedIndex = six ; if( sub==AspectTabs ) { sub = QuantileTabs ; goto Revoke ; } }
		void OnAspectChanged( object subject , PropertyChangedEventArgs arg ) => OnAspectChanged(subject) ;
		void BookGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( BlockSourcesUpdate ) return ; Sources_Update(e) ; Grid_Coloring(sender) ; }
		void Sources_Update( SelectionChangedEventArgs e ) { if( sources is IList<Aspect> sl && !Multiaspected ) { foreach( Pathable path in e.RemovedItems ) sl.IndexIf(a=>a.Raw==path).Use(sl.RemoveAt) ; foreach( Pathable path in e.AddedItems ) if( !sl.Any(a=>a.Raw==path) ) Resource(path).Set(sl.Add) ; Sources = sources ; } else Sources = null ; }
		async internal void Grid_Coloring( object sender ) { for( var success = RecolorGrid(sender)?0:10 ; success>0 ; success -= RecolorGrid(sender)?success:1 ) await Task.Delay(100) ; }
		bool RecolorGrid( object sender ) { var success = true ; if( sender is DataGrid bg );else return success ; var gen = bg.ItemContainerGenerator ; foreach( var item in bg.Items ) if( gen.ContainerFromItem(item) is DataGridRow row ) if( row.Cell(0) is DataGridCell cell && cell.Foreground is SolidColorBrush b && Coloring(item) is Color c && b.Color!=c ) cell.Foreground = new SolidColorBrush(c) ; else success = false ; return success ; }
		void AspectGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; var pts = grid.ItemsSource as Aspect.Point.Iterable ; var asp = pts?.Context ; grid.Columns.Clear() ;
			uint i=0 ; foreach( var ax in asp ) { Filter.Entry.Binding b = ax.Binder ; var o = b.Converter==null||b.Name.No() ; grid.Columns.Add(new DataGridTextColumn{Header=o?ax.Spec:b.Name,Binding=new Binding(o?$"[{i}]":b.Path){StringFormat=b.Form,Converter=b.Converter}}) ; ++i ; }
			if( pts.Context.Raw?.Any(p=>p.Tags!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ; if( pts.Context.Raw?.Any(p=>p.Marklet!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Mark",Binding=new Binding("Marklet")}) ;
		}
		void QuantileGrid_AutoGeneratedColumns( object sender , EventArgs e ) { var grid = sender as DataGrid ; var src = Sources ; grid.Columns.Clear() ; if( grid.ItemsSource is AxedEnumerable axe ) { QuantileData[axe.Ax.Spec] = axe ; Filter.Entry.Binding b = axe.Ax.Binder , cb = axe.Axon?.Binder ; grid.Columns.Add(new DataGridTextColumn{Header=b.Of(axe.Ax.Distribution?.FirstOrDefault()),Binding=new Binding("[0]"){StringFormat=b.Form,Converter=b.Converter}}) ; uint i=1 ; foreach( var asp in src ) grid.Columns.Add(new DataGridTextColumn{Header=asp.Spec,Binding=new Binding($"[{i++}]"){StringFormat=cb.Form,Converter=cb.Converter}}) ; } }
		void SourcesGrid_AutoGeneratedColumns( object sender , EventArgs e ) { var grid = sender as DataGrid ; var asp = Aspect ; grid.Columns.Clear() ; grid.Columns.Add(new DataGridTextColumn{Header="Spec",Binding=new Binding("Spec")}) ; int i=0 ; var f = new HashSet<string>(AspectTraitsGrid.SelectedItems.OfType<Aspect.Traitlet>().Select(t=>t.Spec)) ; foreach( var tr in asp.Trait ) grid.Columns.Add(new DataGridTextColumn{Header=tr.Spec,Binding=new Binding("Trait"){ConverterParameter=i++,Converter=TraitConversion.The},Visibility=f.Contains(tr.Spec)?Visibility.Hidden:Visibility.Visible}) ; if( asp.Taglet!=null ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ; }
		void BookGrid_AutoGeneratedColumns( object sender=null , EventArgs e=null ) => ConGrid_AutoGeneratedColumns(sender??BookGrid,ActionTraits) ;
		void MatrixGrid_AutoGeneratedColumns( object sender , EventArgs e=null ) => ConGrid_AutoGeneratedColumns(sender,MatrixTraits) ;
		void ConGrid_AutoGeneratedColumns( object sender , params string[] traits ) { if( traits==null ) return ; var grid = sender as DataGrid ; grid.Columns.Clear() ; foreach( Filter.Entry.Binding tr in traits ) grid.Columns.Add(new DataGridTextColumn{Header=tr.Name,Binding=new Binding(tr.Path){Converter=tr.Converter,StringFormat=tr.Form}}) ; }
		async void SourcesGrid_ItemsChanged( object sender , System.Windows.Controls.Primitives.ItemsChangedEventArgs e ) { var gen = sender as ItemContainerGenerator ; for( int i=0 , c=gen.Items.Count ; i<c ; ++i ) try { var j=0 ; Retry: if( gen.ContainerFromIndex(i) is DataGridRow row ) row.Cell(0).Foreground = new SolidColorBrush(Coloring(gen.Items[i] as Aspect)) ; else { await Task.Delay(100) ; if( ++j<10 ) goto Retry ; } } catch {} }
		void AspectTabs_Selected( object sender , SelectionChangedEventArgs e ) { var asp = e.AddedItems.Count>0 ? e.AddedItems[0] : null ; switch( (DisplayTable.SelectedItem as TabItem)?.Header ) { case "Aspect" : Aspect = AspectSelection ; break ; case "Spectrum" : (asp as Pathable)?.Spectrum.Set(a=>Aspect=a) ; break ; } }

		#region Hidden
		void AddActionButton_Click( object sender , RoutedEventArgs e ) { var dlg = new OpenFileDialog{Multiselect=true} ; if( dlg.ShowDialog(this)==true ) dlg.FileNames.Each(f=>NewAction(f)) ; }
		void AddAspectAxeButton_Click( object sender , RoutedEventArgs e ) => Aspect.Add(new Axe{Aspect=Aspect as Path.Aspect}.Set(Axes.Add)) ;
		void AddAspectTraitButton_Click( object sender , RoutedEventArgs e ) => Aspect.Trait.Add(new Aspect.Traitlet()) ;
		void AddAspectButton_Click( object sender , RoutedEventArgs e ) => Aspects.Add(new Aspect()) ;
		void AddAxeButton_Click( object sender , RoutedEventArgs e ) => Axes.Add(new Axe()) ;
		void SaveAspectsButton_Click( object sender , RoutedEventArgs e ) => Setup.AspectsPath.Set(p=>Aspects.Each(a=>p.Pathin(a.Spec).WriteAll((string)a))) ;
		#endregion

		Aspect AspectSelection => AspectsGrid.SelectedItems.Count>1 ? new Aspect(AspectsGrid.SelectedItems.OfType<Aspect>()) : AspectsGrid.SelectedItem as Aspect ;
		void DisplayTable_SelectionChanged( object sender , SelectionChangedEventArgs e )
		{
			var tab = e.AddedItems.Count>0 ? e.AddedItems[0] as TabItem : null ; switch( tab?.Header as string )
			{
				case "Aspect" : Aspect = AspectSelection ; ViewType = "Aspect" ; break ;
				case "Spectrum" : Aspect = (((SpectrumTabs.SelectedItem as TabItem)?.Content as DataGrid)?.ItemsSource as Pathable??SpectrumTabs.ItemsSource.OfType<Pathable>().One())?.Spectrum ; ViewType = "Spectrum" ; break ;
				case "Quantile" : ViewType = "Quantile" ; break ;
				case "Graph" : ViewPanel = GraphPanel ; break ;
				case "Map" : ViewPanel = MapPanel ; break ;
			}
		}
		void DataGridDeleteCommandBinding_Executed( object sender , ExecutedRoutedEventArgs e ) => ((sender as DataGrid)?.ItemsSource as IList).Set(l=>(sender as DataGrid)?.SelectedItems.OfType<object>().ToArray().Each(l.Remove)) ;
		void SourcesGridDeleteCommandBinding_Executed( object sender , ExecutedRoutedEventArgs e ) { (sources as IList).Set(l=>(sender as DataGrid)?.SelectedItems.OfType<Aspect>().ToArray().Each(a=>{l.Remove(a);Presources.Remove(a.Raw);})) ; }

		#region Graphing
		void Graph_Draw( object sender , RoutedEventArgs e = null ) { ViewPanel = GraphPanel ; GraphPanel.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : GraphDrawAspect() ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		void Map_Draw( object sender , RoutedEventArgs e = null ) { ViewPanel = MapPanel ; MapPanel.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : MapDrawAspect() ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		string ViewType ; Canvas ViewPanel ; Dictionary<string,AxedEnumerable> QuantileData = new Dictionary<string,AxedEnumerable>() ;
		(double Width,double Height) MainFrameSize => (MainFrame.ColumnDefinitions[1].ActualWidth-ViewScreenBorder.Width,MainFrame.RowDefinitions[1].ActualHeight-ViewScreenBorder.Height) ;
		IEnumerable<Aspect> GraphingSources => Sources.Except(SourcesGrid.SelectedItems.OfType<Aspect>()) ;
		void GraphDrawAspect()
		{
			var axes = AspectAxisGrid.SelectedItems.OfType<Axe>().ToArray() ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 || !( AspectAxisGrid.SelectedItem is Axe xaxe ) ) return ;
			(var width,var height) = ViewFrame = MainFrameSize ; var sources = GraphingSources ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var rng = new Dictionary<string,(double Min,double Max)>() ;
			sources.SelectMany(s=>s).Each(a=>{if(a.Any(q=>q!=null))if(!rng.ContainsKey(a.Spec))rng[a.Spec]=(a.Min().Value,a.Max().Value);else{rng[a.Spec]=(Math.Min(rng[a.Spec].Min,a.Min().Value),Math.Max(rng[a.Spec].Max,a.Max().Value));}}) ; if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v ) => axe.Binder.No() ? Format(v) : axb.Of(v) ;
				for( var m=0 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20);}) ) ;
				for( var m=50 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes) )
				{
					var y = rng[ax] ; axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=height-50 ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			foreach( var asp in sources )
			{
				var xax = asp[xaxe.Spec] ; var color = new SolidColorBrush(Coloring(asp)) ; foreach( var ax in asp ) if( yaxes.Contains(ax.Spec) ) try
				{
					var ptss = new List<(int Count,int From)>() ;
					{
						int c,i ; for( i=0 , c=0 ; i<ax.Count ; ++i ) { var stop = false ; if( xax[i]!=null&&ax[i]!=null ) ++c ; else stop = true ; if( stop||asp.Raw?[i].Mark==Mark.Stop ) { if( c>0 ) ptss.Add((c,i-c+(stop?0:1))) ; c = 0 ; } }
						if( c>0 ) ptss.Add((c,i-c)) ;
					}
					foreach( var pts in ptss ) GraphPanel.Children.Add( new Polyline{
						Stroke = color , StrokeDashArray = Array.IndexOf(yaxes,ax.Spec).Get(j=>j<1?null:new DoubleCollection{j}) ,
						Points = new PointCollection(pts.Count.Steps(pts.From).Select(i=>ScreenPoint(((xax[i].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0)+asp.Offset,height-(ax[i].Value-rng[ax.Spec].Min)/(rng[ax.Spec].Max-rng[ax.Spec].Min).nil()*height??0)))
					} ) ;
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ;
			var co = Coordinates.ToDictionary(c=>c.Axe) ; Coordinates.Clear() ; Hypercube.Each(e=>Coordinates+=co.By(e.Key).Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
		}
		void MapDrawAspect()
		{
			var axes = AspectAxisGrid.SelectedItems.OfType<Axe>().ToArray() ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 || !( AspectAxisGrid.SelectedItem is Axe xaxe ) ) return ;
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var rng = new Dictionary<string,(double Min,double Max)>() ; var sources = GraphingSources ;
			sources.SelectMany(s=>s).Each(a=>{if(a.Any(q=>q!=null))if(!rng.ContainsKey(a.Spec))rng[a.Spec]=(a.Min().Value,a.Max().Value);else{rng[a.Spec]=(Math.Min(rng[a.Spec].Min,a.Min().Value),Math.Max(rng[a.Spec].Max,a.Max().Value));}}) ; if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v , int p ) => axe.Binder.No() ? Format(v,p) : axb.Of(v) ;
				for( var m=0 ; m<=width ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20);}) ) ;
				for( var m=50 ; m<=width ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; MapPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes.Take(1)) )
				{
					var y = rng[ax] ;  axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=height-50 ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			(double X,double Y) sha = ((Coordinates.FirstOrDefault(c=>c.Axe==xaxe.Spec)?.Info??State.Coordination(xaxe.Spec)).Evaluate()??0,(Coordinates.FirstOrDefault(c=>c.Axe==yaxes[0])?.Info??State.Coordination(yaxes[0])).Evaluate()??0) ;
			double zis = Math.Pow(Math.Sqrt(width*height),1D/3D) ; var shift = 0 ; var zi = Setup.PrimaryShape ;
			foreach( var asp in sources )
			{
				var xax = asp[xaxe.Spec] ; var yax = asp[yaxes[0]] ;
				var pts = new List<(System.Windows.Point A,System.Windows.Point B,bool S,double? X,double? Y,(string Spec,double? Val)[] Z)>() ;
				for( int i=0 , c = asp.Points.Count-1 ; i<c ; ++i ) if( xax[i]!=null && yax[i]!=null && xax[i+1]!=null && yax[i+1]!=null && !asp.Points[i].Mark.HasFlag(Mark.Stop) ) try
				{
					var spt0 = ScreenPoint((xax[i].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0,height-(yax[i].Value-rng[yax.Spec].Min)/(rng[yax.Spec].Max-rng[yax.Spec].Min).nil()*height??0) ;
					var spt1 = ScreenPoint((xax[i+1].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0,height-(yax[i+1].Value-rng[yax.Spec].Min)/(rng[yax.Spec].Max-rng[yax.Spec].Min).nil()*height??0) ;
					if( spt0.X>=0 && spt0.Y>=0 && spt1.X<=width && spt1.Y<=height ) pts.Add((spt0,spt1,asp.Points[i+1].Mark.HasFlag(Mark.Stop),xax[i],yax[i],yaxes.Skip(1).Select(z=>(z,asp[z][i])).ToArray())) ;
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				for( var i=1 ; i<yaxes.Length ; ++i ) rng[yaxes[i]]=(pts.Min(p=>p.Z[i-1].Val).Value,pts.Max(p=>p.Z[i-1].Val).Value) ;
				var color = Coloring(asp) ; (double dx,double dy) lv = (0,0) ;
				foreach( var (A,B,S,X,Y,Z) in pts ) try
				{
					var za = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)).ToArray() ; var zb = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)?.Info??State.Coordination(z.Spec)).ToArray() ;
					var zicol = Z.At((zi+1)%2).nil(z=>z.Spec==null) ; var ziaro = Z.At(zi%2).nil(z=>z.Spec==null) ;
					var axcol = zicol.Get(z=>(z.Val-(zb.At((zi+1)%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At((zi+1)%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					var axaro = ziaro.Get(z=>(z.Val-(zb.At(zi%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At(zi%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					if( axcol<zb.At((zi+1)%2)?.Count-za.At((zi+1)%2)?.Size || axaro<zb.At(zi%2)?.Count-za.At(zi%2)?.Size ) continue ;
					var zisc = axcol==null && zicol?.Spec is string sp ? rng[sp].Min : zis ;
					var axarow = ziaro.use(z=>(axaro*zisc%zisc).Signate(zb.At(zi%2)?.Reverse==false?zisc:null as double?)??rng[z.Spec].Min) ;
					double x1 = A.X+shift*sha.X , y1 = A.Y+shift*sha.Y , x2 = B.X+shift*sha.X , y2 = B.Y+shift*sha.Y , ln = Math.Sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)) ; if( ln>0 ) lv = ((x2-x1)/ln,(y2-y1)/ln) ;
					MapPanel.Children.Add( new Line{ X1 =  x1, Y1 = y1 , X2 = x2 , Y2 = y2 ,
						Stroke = axcol.Get(z=>new SolidColorBrush(color*(float)(z%1).Signate(zb.At((zi+1)%2)?.Reverse==false?1:null as double?))) ?? new SolidColorBrush(color) ,
						StrokeThickness = axarow ?? ( axcol==null && (zicol?.Spec??ziaro?.Spec) is string spec ? rng[spec].Min : 1 ) ,
					} ) ;
					if( S ) MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-lv.dy*zis , Y2 = y2+lv.dx*zis , Stroke = Brushes.Black , StrokeThickness = 1 } ) ;
					if( axcol>zb.At((zi+1)%2)?.Count || axaro>zb.At(zi%2)?.Count )
					{
						foreach( var v in Z ) Coordinates.FirstOrDefault(c=>c.Axe==v.Spec).Set(c=>c.Value=v.Val) ;
						Coordinates.FirstOrDefault(c=>c.Axe==xax.Spec).Set(c=>c.Value=X) ; Coordinates.FirstOrDefault(c=>c.Axe==yax.Spec).Set(c=>c.Value=Y) ;
						break ;
					}
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				++shift ;
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			Hypercube.Each(e=>Coordinates+=co[e.Key].FirstOrDefault().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
		}
		void GraphDrawQuantile()
		{
			var axes = AspectAxisGrid.SelectedItems.OfType<Axe>().ToArray() ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; var selasps = GraphingSources.ToArray() ;//SourcesGrid.SelectedItems.Null(s=>s.Count<=0) ;
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=127,G=127,B=127}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var rng = new List<KeyValuePair<string,(double Min,double Max)>>() ;
			var k = 0 ; foreach( var axe in Aspect ) if( axe.Spec!=null && QuantileData.At(axe.Spec) is AxedEnumerable ax && ax.Count()>0 && yaxes.Contains(axe.Spec) )
			{
				var axa = ax.Ax ; Filter.Entry.Binding axb = axa.Binder ; string format( double v ) => (axa?.Binder).No() ? Format(v) : axb.Of(v) ;
				var val = ax.SelectMany(v=>v.Skip(1)) ; ((double Min,double Max) x,(double Min,double Max) y) = ((ax.Min(a=>a[0]),ax.Max(a=>a[0])),(val.Min(),val.Max())) ;
				rng.Add(new KeyValuePair<string,(double Min,double Max)>(ax.Ax.Spec,x)) ; rng.Add(new KeyValuePair<string,(double Min,double Max)>($"Q({ax.Ax.Spec}){ax.Axon?.Spec}",y)) ;
				{
					for( var m=0 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20-10*k);}) ) ;
					for( var m=50 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10+10*k);}) ) ;
					axa = ax.Axon ; axb = ax.Axon?.Binder ; for( var m=height-50 ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,-4);}) ) ;
					if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
				for( int j = 1 , cnt = ax.FirstOrDefault()?.Length??0 ; j<cnt ; ++j ) GraphPanel.Children.Add( new Polyline{
					Stroke = new SolidColorBrush( Coloring(selasps[j-1]/* is Aspect asp?SourceIndex(asp):j-1)*/) ) , StrokeDashArray = k==0?null:new DoubleCollection{k} ,
					Points = new PointCollection(ax.Select(a=>ScreenPoint((a[0]-x.Min)/(x.Max-x.Min)*width,height-(a[j]-y.Min)/(y.Max-y.Min)*height)))
				} ) ;
				++k ;
			}
			Hypercube = rng ; var co = Coordinates.ToDictionary(c=>c.Axe) ; Coordinates.Clear() ;
			rng.Each(e=>Coordinates+=co.By(e.Key).Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder}) ;
		}
		#endregion

		static int DecDigits( double value , int prec = 3 ) => value==0 ? 0 : (int)Math.Max(0,prec-Math.Log10(Math.Abs(value))) ;
		static string Format( double value , int prec = 3 ) => value.ToString("#."+new string('#',DecDigits(value,prec))) ;
		IEnumerable<KeyValuePair<string,(double Min,double Max)>> Hypercube ; (double Width,double Height) ViewFrame ; (Line X,Line Y) MouseCross , ScreenCross ;
		(double Width,double Height) ViewScreenBorder => (DisplayTable.Margin.Left+DisplayTable.Margin.Right+4,30) ;
		static readonly Color[] Colos = new[]{ new Color{A=255,R=255,G=0,B=0} , new Color{A=255,R=0,G=255,B=0} , new Color{A=255,R=0,G=0,B=255} , new Color{A=255,R=191,G=191,B=0} , new Color{A=255,R=0,G=191,B=191} , new Color{A=255,R=191,G=0,B=191} , new Color{A=255,R=223,G=0,B=159} , new Color{A=255,R=159,G=223,B=0} , new Color{A=255,R=0,G=159,B=223} , new Color{A=255,R=159,G=191,B=223} , new Color{A=255,R=223,G=159,B=0} , new Color{A=255,R=0,G=223,B=159} } ;
		static readonly FontStretch[] Fostres = new[]{ FontStretches.UltraExpanded , FontStretches.ExtraExpanded , FontStretches.Expanded , FontStretches.SemiExpanded , FontStretches.Normal , FontStretches.SemiCondensed , FontStretches.Condensed , FontStretches.ExtraCondensed , FontStretches.UltraCondensed } ;
		static readonly FontWeight[] Foweis = new[]{ /*FontWeights.ExtraBlack , FontWeights.Black ,*/ FontWeights.ExtraBold , FontWeights.Bold , FontWeights.SemiBold , FontWeights.Medium , FontWeights.Normal , FontWeights.Light , FontWeights.ExtraLight , FontWeights.Thin } ;
		Color Coloring( int index ) => index<0 ? Colors.Black : Colos[index%Colos.Length] ;
		void AspectAxisGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { var success = RefontAxes(sender) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; /*while( !success ) { await Task.Delay(100) ; success = RefontAxes(sender) ; }*/ }
		bool RefontAxes( object sender )
		{
			var success = true ; if( sender is DataGrid grid );else return success ; var gen = grid.ItemContainerGenerator ; var sel = grid.SelectedItem ; int ix = 0 ; var sels = grid.SelectedItems.OfType<Axe>().ToArray() ;
			foreach( var item in sels ) if( gen.ContainerFromItem(item) is DataGridRow row ) if( row.Cell(0) is DataGridCell cell ) { cell.FontStyle = sel==item?FontStyles.Normal:FontStyles.Italic ; cell.FontStretch = item==sel?FontStretches.Normal:Fostres[ix%Fostres.Length] ; cell.FontWeight = item==sel?FontWeights.Bold:Foweis[ix%Foweis.Length] ; if( item!=sel ) ++ix ; } else success = false ;
			foreach( var item in grid.Items.OfType<Axe>().Except(sels) ) if( gen.ContainerFromItem(item) is DataGridRow row ) if( row.Cell(0) is DataGridCell cell && row.Cell(1) is DataGridCell coll ) { cell.FontStyle = coll.FontStyle ; cell.FontStretch = coll.FontStretch ; cell.FontWeight = coll.FontWeight ; } else success = false ;
			return success ;
		}

		#region Coordinates
		void Main_MouseMove( object sender , MouseEventArgs e ) => MousePoint = Mouse.GetPosition(ViewPanel) ;
		public class Coordinate : INotifyPropertyChanged
		{
			Main Context ;
			public event PropertyChangedEventHandler PropertyChanged ;
			public Coordinate( Main context , string axe ) => Info = (_byte = (Context = context).State[Axe = axe]).ParseCoinfo() ;
			public string Axe { get; }
			public double? Value { get => value ; internal set { this.value = value ; PropertyChanged.On(this,"Value,View") ; } } double? value ;
			public string View => Binding.Of(value) ;
			public string Byte { get => _byte ; set { if( Byte==value ) return ; Context.State[Axe] = _byte = value ; Info = value.ParseCoinfo() ; PropertyChanged.On(this,"Byte") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; } } string _byte ;
			public (double? Byte,uint? Count,bool Reverse)? Info { get => info ?? Context.State.Coordination(Axe) ; set { if( info.Equals(value) ) return ; info = value ; Byte = value.StringCoinfo() ; } } (double? Byte,uint? Count,bool Reverse)? info ;
			public (double Min,double Max) Range ;
			public string Bond { set => Binding = value ; } Filter.Entry.Binding Binding ;
			public string At { get => at ; set { if( value==at ) return ; Size = (at=value).Parse<uint>() ; PropertyChanged.On(this,"At") ; } } string at ;
			public uint? Size { get =>size ; set { if( value==size ) return ; size = value ; PropertyChanged.On(this,"Size") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; At = value.Stringy() ; } } uint? size ;
		}
		public Aid.Collections.ObservableList<Coordinate> Coordinates { get; private set; } = new Aid.Collections.ObservableList<Coordinate>() ;
		public System.Windows.Point? MousePoint
		{
			get => mousePoint ; set
			{
				MouseCross.X.Set(ViewPanel.Children.Remove) ; MouseCross.Y.Set(ViewPanel.Children.Remove) ; if( value==null || value?.X<0 || value?.Y<0 || value?.X>ViewFrame.Width || value?.Y>ViewFrame.Height ) return ;
				var asp = Hypercube is Array ; PropertyChanged.On( this, "MousePoint", (mousePoint=value).Use(m=>Hypercube.Each(a=>CoordinateSet(m,a,asp))) ) ;
				ViewPanel.Children.Add( MouseCross.X = new Line{ Stroke=Brushes.Gray , X1=0 , X2=ViewFrame.Width , Y1=value.Value.Y , Y2=value.Value.Y } ) ;
				ViewPanel.Children.Add( MouseCross.Y = new Line{ Stroke=Brushes.Gray , Y1=0 , Y2=ViewFrame.Height , X1=value.Value.X , X2=value.Value.X } ) ;
			}
		}
		void CoordinateSet( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a , bool asp )
		{
			var co = Coordinates.First(c=>c.Axe==a.Key) ; co.Value = ( asp ? AspectAxisGrid.SelectedItem is Axe x && a.Key==x.Spec : !a.Key.StartsBy("Q(") ) ?
			ScreenX(AxeXByMouse(m,a),a.Value) : ViewPanel==GraphPanel || Coordinates.IndexOf(co)<2 ? ScreenY(AxeYByMouse(m,a),a.Value) : AxeZByMouse(a.Key) ;
		}
		double AxeXByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => m.X/ViewFrame.Width*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double AxeYByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => (ViewFrame.Height-m.Y)/ViewFrame.Height*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double? AxeZByMouse( string a )
		{
			var x = Coordinates[0]?.Value ; var y = Coordinates[1]?.Value ; var ax = Coordinates[0]?.Axe ; var ay = Coordinates[1]?.Axe ; Aspect.Point? op = null ; double? ov = null , cv = null ;
			foreach( var src in Sources ) foreach( var pt in src.Points ) if( (cv=(pt[ax]-x).Sqr()+(pt[ay]-y).Sqr())<ov || ov==null ) { op = pt ; ov = cv ; }
			return op?[a] ;
		}
		#endregion

		#region Focusing
		System.Windows.Point? mousePoint , screenPoint ; System.Windows.Rect? ScreenRect ;
		System.Windows.Point? ScreenOrigin
		{
			get => screenPoint ; set
			{
				ScreenCross.X.Set(ViewPanel.Children.Remove) ; ScreenCross.Y.Set(ViewPanel.Children.Remove) ; var p = ScreenMouse ; screenPoint = value.Get(v=>p) ; if( value==null ) return ;
				ViewPanel.Children.Add( ScreenCross.X = new Line{ Stroke=Brushes.Orange , X1=0 , X2=ViewFrame.Width , Y1=value.Value.Y , Y2=value.Value.Y } ) ;
				ViewPanel.Children.Add( ScreenCross.Y = new Line{ Stroke=Brushes.Orange , Y1=0 , Y2=ViewFrame.Height , X1=value.Value.X , X2=value.Value.X } ) ;
			}
		}
		System.Windows.Point? ScreenMouse { get { if( ScreenRect==null || MousePoint==null ) return MousePoint ; (var width,var height) = MainFrameSize ; var p = MousePoint.Value ; var r = ScreenRect.Value ; return new System.Windows.Point(p.X*r.Size.Width/width+r.Location.X,p.Y*r.Size.Height/height+r.Location.Y) ; } }
		void ViewPanel_MouseDown( object sender, MouseButtonEventArgs e ) => ScreenOrigin = MousePoint ;
		void DisplayTable_MouseUp( object sender, MouseButtonEventArgs e ) { if( ScreenMouse==ScreenOrigin ) return ; var scr = ScreenOrigin.Get(s=>ScreenMouse.use(p=>new Rect(s,p))) ; if( scr==ScreenRect ) return ; ScreenRect = scr ; if( GraphTab.IsSelected ) Graph_Draw(sender) ; if( MapTab.IsSelected ) Map_Draw(sender) ; }
		void DisplayTable_MouseDoubleClick( object sender, MouseButtonEventArgs e ) { /*var draw = ScreenRect!=null ;*/ ScreenOrigin = null ; ScreenRect = null ; /*if( draw )*/ if( GraphTab.IsSelected ) Graph_Draw(sender,e) ; else if( MapTab.IsSelected ) Map_Draw(sender,e) ; }
		System.Windows.Point ScreenPoint( double x , double y ) => new System.Windows.Point(ScreenX(x),ScreenY(y)) ;
		double ScreenX( double x ) { if( ScreenRect==null ) return x ; var r = ScreenRect.Value ; return (x-r.Location.X)*ViewFrame.Width/r.Size.Width ; }
		double ScreenY( double y ) { if( ScreenRect==null ) return y ; var r = ScreenRect.Value ; return (y-r.Location.Y)*ViewFrame.Height/r.Size.Height ; }
		double ScreenX( double x , (double Min,double Max) e ) { if( ScreenRect==null ) return x ; var r = ScreenRect.Value ; var q = (e.Max-e.Min)/ViewFrame.Width ; var fx = (x-e.Min)/q ; return e.Min+r.Location.X*q+fx*r.Width/ViewFrame.Width*q ; }
		double ScreenY( double y , (double Min,double Max) e ) { if( ScreenRect==null ) return y ; var r = ScreenRect.Value ; var q = (e.Max-e.Min)/ViewFrame.Height ; var fy = (e.Max-y)/q ; return e.Max-r.Location.Y*q-fy*r.Height/ViewFrame.Height*q ; }
		#endregion

		#region Stepping
		void Coordinates_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.001) ;
		void Coordinates_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.001) ;
		void Coordinates_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.01) ;
		void Coordinates_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.01) ;
		void Coordinates_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.1) ;
		void Coordinates_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.1) ;
		void Coordinates_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(.001) ;
		void Coordinates_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(null) ;
		void Coordinates_CountLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-1) ;
		void Coordinates_CountRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+1) ;
		void Coordinates_CountUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-10) ;
		void Coordinates_CountDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+10) ;
		void Coordinates_CountPageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-100) ;
		void Coordinates_CountPageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+100) ;
		void Coordinates_CountHome_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(0) ;
		void Coordinates_CountEnd_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(null) ;
		void Coordinates_AtLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(-1) ;
		void Coordinates_AtRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(+1) ;
		void Coordinates_AtUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(1) ;
		void Coordinates_AtDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(null) ;
		void CoordinatesMove( double step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(Math.Max(.001*(c.Range.Max-c.Range.Min),(i.Byte+step*(c.Range.Max-c.Range.Min))??c.Range.Max-c.Range.Min),i.Count,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSet( double? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(state*(c.Range.Max-c.Range.Min),i.Count is uint m?state is double s?s==0?i.Count:Math.Min((uint)((c.Range.Max-c.Range.Min)/s),m):1U:null as uint?,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(i.Byte,i.Count.use(v=>(uint)Math.Min(i.Byte is double b?(c.Range.Max-c.Range.Min)/b:1,Math.Max(0,(int)v+step))),i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(i.Byte,state,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=c.Size.use(a=>(uint)Math.Max(0,(int)a+step))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=state) ; GridFocusHold(CoordinatesGrid,sel) ; }
		#endregion

		async void GridFocusHold( DataGrid grid , IEnumerable<object> sel ) { await Task.Delay(10) ; sel.Each(s=>grid.SelectedItems.Add(s)) ; grid.Focus() ; }

		#region Drifting
		void Source_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-1) ;
		void Source_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+1) ;
		void Source_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<5)) ;
		void Source_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<5)) ;
		void Source_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<10)) ;
		void Source_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<10)) ;
		void Source_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(0) ;
		void Source_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(MainFrameSize.Width) ;
		void SourceDriftMove( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset+=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		void SourceDriftSet( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		#endregion
	}
	public class QuantileSubversion : IMultiValueConverter
	{
		public object Convert( object[] values , Type targetType , object parameter , CultureInfo culture )
		{
			if( values.At(0) is Axe ax && values.At(1) is IEnumerable<Aspect> src );else return null ;
			var srcf = (values.At(3) as IEnumerable)?.OfType<Aspect>() ; var srcs = src.Except(srcf).Where(a=>a[ax.Spec]!=null) ;
			var dis = (ax.Distribution??srcs.SelectMany(s=>s[ax.Spec].Distribution??Enumerable.Empty<double>()).Distinct().OrderBy(v=>v)).ToArray() ;
			var axon = values.At(2) as Axe ; var res = srcs.Select(a=>a[ax.Spec].Quantile[dis,a[axon?.Spec]].ToArray()).ToArray() ;
			try { return new AxedEnumerable{ Ax = ax , Axon = axon , Content = res.Length>0 && res[0].Length>0 ? res[0].Length.Steps().Select(i=>res.Length.Steps().Select(j=>res[j][i]).Prepend(dis[i+(dis.Length>res[0].Length?1:0)]).ToArray()) : Enumerable.Empty<double[]>() } ; }
			catch( System.Exception e ) { Trace.TraceWarning(e.Stringy()) ; return new AxedEnumerable{ Ax = ax , Axon = axon , Content = Enumerable.Empty<double[]>() } ; }
		}
		public object[] ConvertBack( object value , Type[] targetTypes , object parameter , CultureInfo culture ) => null ;
	}
	public class TraitConversion : IValueConverter
	{
		public static TraitConversion The = new TraitConversion() ; static readonly IDictionary<string,Filter.Entry.Binding> Binder = new Dictionary<string,Filter.Entry.Binding>() ;
		Filter.Entry.Binding Bind( string form ) => Binder.TryGetValue(form??string.Empty,out var v) ? v : Binder[form??string.Empty] = form ;
		public object Convert( object value , Type targetType , object parameter , CultureInfo culture ) => value is Aspect.Traits t ? t[(int)parameter].Get(r=>Bind(r.Bond).Of(r.Value)) : null ;
		public object ConvertBack( object value , Type targetType , object parameter , CultureInfo culture ) => null ;
	}
	struct AxedEnumerable : IEnumerable<double[]> { public Axe Ax , Axon ; internal IEnumerable<double[]> Content ; public IEnumerator<double[]> GetEnumerator() => Content?.GetEnumerator()??Enumerable.Empty<double[]>().GetEnumerator() ; IEnumerator IEnumerable.GetEnumerator() => GetEnumerator() ; }
	public class Filter : Aid.Collections.ObservableList<Filter.Entry>
	{
		public class Entry
		{
			const string Separator = " \x1 Filet \x2 " ;
			public bool Rex { get => rex && !Filter.Void() ; set => rex = value ; } bool rex ;
			public string Filter { get => filter ; set { if( (value=value.Null(v=>v.Void()))==filter ) return ; filter = value ; Dirty = true ; } } string filter ;
			public string Traits { get => traits ; set { if( (value=value.Null(v=>v.Void()))==traits ) return ; traits = value ; Dirty = true ; } } string traits ;
			public string Matrix { get => matrix ; set { if( (value=value.Null(v=>v.Void()))==matrix ) return ; matrix = value ; Dirty = true ; } } string matrix ;
			public string Associer { get => associer ; set { if( (value=value.Null(v=>v.Void()))==associer ) return ; associer = value ; Dirty = true ; } } string associer ;
			public string Matter { get => matter ; set { if( (value=value.Null(v=>v.Void()))==matter ) return ; matter = value ; Dirty = true ; } } string matter ;
			public string Query { get => query ; set { if( (value=value.Null(v=>v.Void()))==query ) return ; query = value ; Dirty = true ; } } string query ;
			public bool Empty => Filter.No() && Traits.No() && Matrix.No() && Associer.No() && Matter.No() && Query.No() ;
			public bool Dirty ;
			public static explicit operator string( Entry entry ) => entry.Get(e=>string.Join(Separator,e.Rex?" ":string.Empty,e.Filter,e.Traits,e.Matrix,e.Associer,e.Matter,e.Query)) ;
			public static implicit operator Entry( string entry ) => entry.Get(e=>{ var f = e.Separate(Separator) ; return f.Length<=1 ? null : new Entry{ rex = f[0]==" " , filter = f.At(1) , traits = f.At(2) , matrix = f.At(3) , associer = f.At(4) , matter = f.At(5) , query = f.At(6) } ; }) ;
			public Func<Objective,bool> ToFilter<Objective>() => Rex ? Filter.Matcherex<Objective>() : Filter.Compile<Func<Objective,bool>>() ;
			public Func<IEnumerable<Objective>,IEnumerable<Objective>> ToQuery<Objective>() => Query.Compile<Func<IEnumerable<Objective>,IEnumerable<Objective>>>() ;
			public Func<Objective,bool> ToAssocier<Objective>() => Associer.Compile<Func<Objective,bool>>() ;
			public (Func<Objective,bool> Filter,Func<Enhancer,bool> Associer,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query) ToRefiner<Objective,Enhancer>() => (ToFilter<Objective>(),ToAssocier<Enhancer>(),ToQuery<Objective>()) ;
			public struct Binding
			{
				public string Path , Name , Format , Align ; public IValueConverter Converter ; 
				public string Form => Align.No() ? Format : Format.No() ? $"{{0,{Align}}}" : $"{{0,{Align}:{Format}}}" ;
				public string Reform => Align.No()&&!Format.No() ? $"{{0:{Format}}}" : Form ;
				public static implicit operator Binding( string value ) => new Binding(value) ;
				public Binding( string value )
				{
					if( value?.TrimStart().StartsBy("(")==true ) { var cvt = value.LeftFromScoped(true,'/',',',':') ; Converter = new Aid.Converters.LambdaConverter{Forward=cvt} ; Path = null ; value = value.RightFromFirst(cvt) ; } else { Path = value.LeftFrom(true,':',',','/') ; Converter = null ; }
					Name = value.LeftFrom(true,':',',').RightFromFirst('/',true) ; Format = value.RightFromFirst(':') ; Align = value.LeftFrom(':').RightFrom(',') ;
				}
				public string Of( object value ) => Reform.Form( Converter is IValueConverter c ? c.Convert(value,null,null,null) : value ) ;
			}
		}
		const string Separator = " \x1 Filter \x2\n" ;
		public static explicit operator string( Filter filter ) => filter.Get(f=>string.Join(Separator,f.Where(e=>!e.Empty).Select(e=>(string)e))) ;
		public static implicit operator Filter( string filter ) => filter.Get(f=>new Filter{Sensible=true}.Set(t=>f.Separate(Separator).Each(e=>t.Add(e)))) ;
	}
	public struct Associable { public Pathable Path ; public Aspect Aspect ; public Associable( Pathable path , Aspect aspect ) { Path = path ; Aspect = aspect ; } public  static implicit operator Associable( (Pathable path,Aspect aspect) arg ) => new Associable(arg.path,arg.aspect) ; }
	class Presources : IEnumerable<Pathable>
	{
		IList Origin ; List<Pathable> Basis ; DataGrid Grid ; Main Main ;
		public Presources( DataGrid grid , Main main ) { Origin = ( Grid = grid ).SelectedItems ; Main = main ; grid.SelectionChanged += Grid_SelectionChanged ; }
		void Grid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( Main.BlockSourcesUpdate ) return ; e.RemovedItems.OfType<Pathable>().Each(p=>Basis?.Remove(p)) ; e.AddedItems.OfType<Pathable>().Each(p=>Basis?.Remove(p)) ; }
		IEnumerable<Pathable> Original => Origin.OfType<Pathable>() ;
		public IEnumerator<Pathable> GetEnumerator() => ( Basis is List<Pathable> b ? b.Union(Original) : Original ).GetEnumerator() ; IEnumerator IEnumerable.GetEnumerator() => GetEnumerator() ;
		public int IndexOf( Pathable path ) => Basis?.IndexOf(path) is int i && i>=0 ? i : Origin.IndexOf(path) is int j && j>=0 ? j+(Basis?.Count??0) : -1 ;
		public void Snapshot() => Basis = ( Basis is List<Pathable> b ? b.Union(Original):Original ).ToList() ;
		public void Clean() => Basis = null ;
		public void Remove( Pathable path ) { Basis?.Remove(path) ; if( Origin.Contains(path) ) Origin.Remove(path) ; else Main.Grid_Coloring(Grid) ; }
		public void Reselect() { bool recolor = false ; if( Basis?.Intersect(Grid.Items.OfType<Pathable>()).ToArray() is IEnumerable<Pathable> join ) { foreach( var path in join.Intersect(Original) ) Basis?.Remove(path) ; if( join.Except(Original).ToArray() is Pathable[] exce && exce.Length>0 ) foreach( var path in exce ) Origin.Add(path) ; else recolor = true ; } if( recolor ) Main.Grid_Coloring(Grid) ; }
	}
	static class MainExtension
	{
		public static IEnumerable<Objective> Issue<Objective>( this IEnumerable<Objective> items , params (Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)[] refine ) => items==null ? null : refine?.Length>0 ? refine?.Length>1 ? refine.SelectMany(items.Issue).Distinct() : items.Issue(refine[0]) : items ;
		public static IEnumerable<Objective> Issue<Objective>( this IEnumerable<Objective> items , (Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query) refine ) => items==null ? null : refine.Query==null ? refine.Filter==null ? items : items.Where(refine.Filter) : refine.Filter==null ? refine.Query(items) : refine.Query(items.Where(refine.Filter)) ;
	}
}
