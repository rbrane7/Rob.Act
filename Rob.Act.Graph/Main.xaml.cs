using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.ComponentModel;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Diagnostics;
using Microsoft.Win32;
using Aid.Extension;
using System.Collections.Specialized;
using System.Globalization;
using Aid.IO;

namespace Rob.Act.Analyze
{
	using Book = Gen.Book ;
	/// <summary>
	/// Interaction logic for MainWindow.xaml
	/// </summary>
	public partial class Main : Window , INotifyPropertyChanged
	{
		public static Settings Setup => setup?.Result ; static readonly Aid.Prog.Setup<Settings> setup = (Resetup,e=>Trace.TraceError($"Setup {e}")) ;
		static Aid.Prog.Doct Doct = (Setup.Doctee.Uri(),e=>Trace.TraceError($"Doctor {e}")) ;
		static void Resetup( Settings past )
		{
			if( Doct?["Main"] is Main main );else return ;
			if( Setup?.ActionTraits?.Equates(past?.ActionTraits)==false ) main.Dispatcher.Invoke(()=>main.BookGrid_AutoGeneratedColumns(main.BookGrid)) ;
			if( Setup?.SpectrumBinds?.Equates(past?.SpectrumBinds)==false ) main.Book.Each(p=>p.Spectrum.Reform(Setup.SpectrumBinds)) ;
			if( Setup?.SubjectMass.Equates(past?.SubjectMass)==false ) Basis.Mass = Setup.SubjectMass ;
		}
		public State State { get => state ; private set => state = (value??new State()).Set(s=>s.Context=this) ; } State state ;
		FileSystemWatcher[] WorkoutsWatchers ;
		public event PropertyChangedEventHandler PropertyChanged ;
		void PropertyChangedOn<Value>( string properties , Value value ) { PropertyChanged.On(this,properties,value) ; if( properties.Consists("Sources") ) if( GraphTab.IsSelected ) Graph_Draw(this) ; else if( MapTab.IsSelected ) Map_Draw(this) ; }
		public Main() { InitializeComponent() ; AppDomain.CurrentDomain.Load(typeof(AxeOperations).Assembly.FullName) ; new Aid.Prog.Setup().Go() ; ViewPanel = GraphPanel ; DataContext = this ; Doct += (this,"Main") ; Aspectables.The = ()=>Book.Select(p=>p.Spectrum).Union(Aspects) ; SourcesGrid.ItemContainerGenerator.ItemsChanged += SourcesGrid_ItemsChanged ; Load() ; }
		void Load()
		{
			Setup.WorkoutsPaths.SeparateTrim(',').SelectMany(l=>l.MatchingFiles()).EachGuard(f=>NewAction(f,Setup?.WorkoutsFilter),(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			Setup.AspectsPaths.SeparateTrim(',').SelectMany(l=>l.MatchingFiles()).EachGuard(f=>NewAspect(f,Setup?.AspectsFilter),(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			WorkoutsWatchers = Setup.WorkoutsPaths.SeparateTrim(',').Select(l=>new FileSystemWatcher(l){EnableRaisingEvents=true}.Set(w=>{ w.Edited += NewAction ; w.Deleted += (s,a)=>Book-=p=>p.Origin==a.FullPath ; })).ToArray() ;
			State = new State{ Context = this } ;
		}
		protected override void OnClosing( CancelEventArgs e ) { Doct?.Dispose() ; base.OnClosing(e) ; }
		protected override void OnClosed( EventArgs e ) { base.OnClosed(e) ; Process.GetCurrentProcess().Kill() ; }
		void NewAction( string file , Predicate<Pathable> filter = null ) => file.Reconcile().Internalize().Set(p=>p.Origin=file).Set(Translation.Partitionate).Set(p=>p.Spectrum.Reform(Setup.SpectrumBinds)).Set(p=>{Book|=(filter as Predicate<Pathable>)?.Invoke(p)!=false?p:null;if(Book.Contains(p)){ActionEnhancing(p,ActiveRefiner);Dispatcher.Invoke(SaveBook);}}) ;
		void NewAction( object subject , System.IO.FileSystemEventArgs arg ) => NewAction(arg.FullPath,Setup?.WorkoutsFilter) ;
		void NewAspect( string file , Predicate<Aspect> filter = null ) => ((Aspect)file.ReadAllText()).Set(a=>a.Origin=file).Set(a=>Aspects+=(filter as Predicate<Aspect>)?.Invoke(a)!=false?a:null) ;
		public Book Book { get ; private set ; } = new Book("Main") ;
		public Filter ActionFilter { get => actionFilter ; internal set { if( value==actionFilter ) return ; actionFilter = value ; PropertyChanged.On(this,"ActionFilter") ; } } Filter actionFilter ;
		public Filter SourceFilter { get => sourceFilter ; internal set { if( value==sourceFilter ) return ; sourceFilter = value ; PropertyChanged.On(this,"SourceFilter") ; } } Filter sourceFilter ;
		public Filter AspectFilter { get => aspectFilter ; internal set { if( value==aspectFilter ) return ; aspectFilter = value ; PropertyChanged.On(this,"AspectFilter") ; } } Filter aspectFilter ;
		string[] ActionTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Traits.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.ActionTraits ;
		string[] MatrixTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Matrix.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.MatrixTraits?.Concat(BookGrid.SelectedItems.OfType<Path>().SelectMany(p=>p.Metax?.Bonds??Enumerable.Empty<string>()).Distinct()).ToArray() ;
		void ActionFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Pathable,Associable>(sender,(f,a)=>{Book.Filter=f;ActionsEnhancing(a);BookGrid_AutoGeneratedColumns();}) ;
		void SourceFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Aspect>(sender,f=>{SourcesFilter=a=>f(a);Sources=sources;}) ;
		void AspectFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Aspect>(sender,f=>Aspects.Filter=f) ;
		void FilterGrid_SelectionChanged<Objective>( object sender , Action<Predicate<Objective>> doing ) => (sender as DataGrid)?.SelectedItems.OfType<Filter.Entry>().Select(f=>f.ToFilter<Objective>()).Where(f=>f!=null).ToArray().Get(f=>new Predicate<Objective>(o=>f.Length<=0||f.Any(i=>i(o)))).Set(doing) ;
		IEnumerable<(Predicate<Objective> Filter,Predicate<Enhancer> Associer)> Refiner<Objective,Enhancer>( DataGrid sender ) => sender?.SelectedItems.OfType<Filter.Entry>().Select(f=>f.ToRefiner<Objective,Enhancer>()).Where(f=>f.Filter!=null||f.Associer!=null) ;
		(Predicate<Pathable> Filter,Predicate<Associable> Associer)[] ActiveRefiner ; Metax ActiveMetax ;
		void FilterGrid_SelectionChanged<Objective,Enhancer>( object sender , Action<Predicate<Objective>,(Predicate<Objective> Filter,Predicate<Enhancer> Associer)[]> doing ) => Refiner<Objective,Enhancer>(sender as DataGrid)?.ToArray().Set(r=>ActiveRefiner=r as (Predicate<Pathable> Filter,Predicate<Associable> Associer)[]).Set(f=>doing(new Predicate<Objective>(o=>f.Length<=0||f.Any(i=>i.Filter?.Invoke(o)!=false)),f)) ;
		public Aid.Collections.ObservableList<Aspect>.Filtered Aspects { get ; private set ; } = new Aid.Collections.ObservableList<Aspect>.Filtered{Sensible=true} ;
		void ActionsEnhancing( params (Predicate<Pathable> Filter,Predicate<Associable> Associer)[] refiner ) { ActiveMetax = null ; foreach( var path in Book ) ActionEnhancing(path,refiner) ; Dispatcher.Invoke(SaveBook) ; }
		void ActionEnhancing( Pathable path , params (Predicate<Pathable> Filter,Predicate<Associable> Associer)[] refiner ) { if( refiner==null || path==null ) return ; path.Spectrum.Trait.Clean() ; foreach( var refine in refiner ) if( refine.Filter?.Invoke(path)!=false ) foreach( var asp in Aspects.Entries ) if( (refine.Associer?.Invoke((path,asp))??Setup.ActionAssocier?.Invoke(path,asp))==true ) new Aspect(asp){Source=path.Spectrum}.Set(a=>{path.Spectrum.Trait.Add(a.Trait);path.Spectrum.Tager+=a.Tager;}) ; PathEnhancing(path as Path) ; }
		void PathEnhancing( Path path ) => path.Set(p=>p.Metax=ActiveMetax??(ActiveMetax=new Metax(p.Metax?.Base??p.Dimension)))?.Populate() ;
		void SaveBook() { if( ActionFilterGrid.SelectedItems.Count==1 && (ActionFilterGrid.SelectedItem as Filter.Entry)?.Matter.Null(v=>v.Void()) is string matter && Book.Count>0 && Setup?.WorkoutsPath is string path ) try{Book.Save(path,matter);}catch(System.Exception e){Trace.TraceError("Save Book failed on {0}:{1} : {2}",path,matter,e);} }
		public Aid.Collections.ObservableList<Axe> Axes { get ; private set ; } = new Aid.Collections.ObservableList<Axe>() ;
		public Aspect Aspect { get => Respect ; protected set { if( value==Aspect ) return ; Aspect.Set(a=>{a.CollectionChanged-=OnAspectChanged;a.PropertyChanged-=OnAspectChanged;}) ; (Respect=value).Set(a=>{a.CollectionChanged+=OnAspectChanged;a.PropertyChanged+=OnAspectChanged;}) ; Sources = null ; } } Aspect Respect ;
		public IEnumerable<Aspect> Sources { get => SourcesFilter is Func<Aspect,bool> f ? Resources.Where(f) : Resources ; set => PropertyChangedOn("Aspect,Sources",sources=value) ; } IEnumerable<Aspect> sources ; Func<Aspect,bool> SourcesFilter ;
		new IEnumerable<Aspect> Resources => sources ?? ( sources = ( Aspect==null ? Enumerable.Empty<Aspect>() : Aspect is Path.Aspect ? BookGrid.SelectedItems.OfType<Pathable>().Select(s=>s.Spectrum) : BookGrid.SelectedItems.OfType<Pathable>().Get(p=>AspectMultiToggle.IsChecked==true?p.Select(s=>s.Spectrum).ToArray().Get(s=>Math.Min(AspectMultiCount.Text.Parse(0),s.Length).Get(c=>c>0?c.Steps().Select(i=>new Aspect(Aspect,true){Sources=s.Skip(i).Concat(s.Take(i)).ToArray()}):new Aspect(Aspect,true){Sources=s}.Times())):p.Select(s=>new Aspect(Aspect){Source=s.Spectrum})) ).ToArray() ) ;
		void SourcesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => Sources = sources ;
		void CoordinatesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( MapTab.IsSelected ) Map_Draw(this) ; }
		void OnAspectChanged( object subject , NotifyCollectionChangedEventArgs arg=null ) { var sub = Aspect is Path.Aspect ? SpectrumTabs : AspectTabs ; Revoke : var six = sub.SelectedIndex ; if( sub==AspectTabs || sub==QuantileTabs ) Sources = null ; sub.SelectedIndex = -1 ; sub.SelectedIndex = six ; if( sub==AspectTabs ) { sub = QuantileTabs ; goto Revoke ; } }
		void OnAspectChanged( object subject , PropertyChangedEventArgs arg ) => OnAspectChanged(subject) ;
		void AddActionButton_Click( object sender , RoutedEventArgs e ) { var dlg = new OpenFileDialog{Multiselect=true} ; if( dlg.ShowDialog(this)==true ) dlg.FileNames.Each(f=>NewAction(f)) ; }
		void BookGrid_SelectionChanged( object sender , SelectionChangedEventArgs e )
		{
			Sources = null ; if( sender is DataGrid bg ); else return ; var sel = bg.SelectedItems.Cast<Pathable>() ; var i=0 ;
			foreach( var item in sel ) { if( bg.ItemContainerGenerator.ContainerFromItem(item) is DataGridRow row && row.Cell(0) is DataGridCell cell && cell.Foreground is SolidColorBrush b && b.Color!=Colos[i%Colos.Length] ) cell.Foreground = new SolidColorBrush(Colos[i%Colos.Length]) ; ++i ; }
			foreach( var item in bg.Items.Cast<Pathable>().Except(sel) ) if( bg.ItemContainerGenerator.ContainerFromItem(item) is DataGridRow row ) if( row.Cell(0).Foreground is SolidColorBrush b && b.Color!=Colors.Black ) row.Cell(0).Foreground = Brushes.Black ;
		}
		void AspectGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; var pts = grid.ItemsSource as Aspect.Point.Iterable ; var asp = pts?.Context ; grid.Columns.Clear() ;
			uint i=0 ; foreach( var ax in asp ) { Filter.Entry.Binding b = ax.Binder ; var o = b.Converter==null||b.Name.No() ; grid.Columns.Add(new DataGridTextColumn{Header=o?ax.Spec:b.Name,Binding=new Binding(o?$"[{i}]":b.Path){StringFormat=b.Form,Converter=b.Converter}}) ; ++i ; }
			if( pts.Context.Raw?.Any(p=>p.Tags!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ; if( pts.Context.Raw?.Any(p=>p.Marklet!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Mark",Binding=new Binding("Mark")}) ;
		}
		void QuantileGrid_AutoGeneratedColumns( object sender , EventArgs e ) { var grid = sender as DataGrid ; var src = Sources ; grid.Columns.Clear() ; if( grid.ItemsSource is AxedEnumerable axe ) { QuantileData[axe.Ax.Spec] = axe ; Filter.Entry.Binding b = axe.Ax.Binder , cb = axe.Axon?.Binder ; grid.Columns.Add(new DataGridTextColumn{Header=b.Of(axe.Ax.Distribution?.FirstOrDefault()),Binding=new Binding("[0]"){StringFormat=b.Form,Converter=b.Converter}}) ; uint i=1 ; foreach( var asp in src ) grid.Columns.Add(new DataGridTextColumn{Header=asp.Spec,Binding=new Binding($"[{i++}]"){StringFormat=cb.Form,Converter=cb.Converter}}) ; } }
		void SourcesGrid_AutoGeneratedColumns( object sender , EventArgs e ) { var grid = sender as DataGrid ; if( Aspect is Aspect asp ); else return ; grid.Columns.Clear() ; grid.Columns.Add(new DataGridTextColumn{Header="Spec",Binding=new Binding("Spec")}) ; int i=0 ; foreach( var tr in asp.Trait ) grid.Columns.Add(new DataGridTextColumn{Header=tr.Spec,Binding=new Binding("Trait"){ConverterParameter=i++,Converter=TraitConversion.The}}) ; if( asp.Taglet!=null ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ; }
		void BookGrid_AutoGeneratedColumns( object sender=null , EventArgs e=null ) => ConGrid_AutoGeneratedColumns(sender??BookGrid,ActionTraits) ;
		void MatrixGrid_AutoGeneratedColumns( object sender , EventArgs e=null ) => ConGrid_AutoGeneratedColumns(sender,MatrixTraits) ;
		void ConGrid_AutoGeneratedColumns( object sender , params string[] traits ) { if( traits==null ) return ; var grid = sender as DataGrid ; grid.Columns.Clear() ; foreach( Filter.Entry.Binding tr in traits ) grid.Columns.Add(new DataGridTextColumn{Header=tr.Name,Binding=new Binding(tr.Path){Converter=tr.Converter,StringFormat=tr.Form}}) ; }
		async void SourcesGrid_ItemsChanged( object sender , System.Windows.Controls.Primitives.ItemsChangedEventArgs e ) { var gen = sender as ItemContainerGenerator ; for( int i=0 , c=gen.Items.Count ; i<c ; ++i ) { Retry: if( gen.ContainerFromIndex(i) is DataGridRow row ) row.Cell(0).Foreground = new SolidColorBrush(Colos[BookGrid.SelectedItems.IndexOf((gen.Items[i] as Aspect)?.Raw)%Colos.Length]) ; else { await Task.Delay(100) ; goto Retry ; } } }
		void AspectTabs_Selected( object sender , SelectionChangedEventArgs e ) { var asp = e.AddedItems.Count>0 ? e.AddedItems[0] : null ; switch( (DisplayTable.SelectedItem as TabItem)?.Header ) { case "Aspect" : (asp as Aspect).Set(a=>Aspect=a) ; break ; case "Spectrum" : (asp as Pathable)?.Spectrum.Set(a=>Aspect=a) ; break ; } }
		void AddAspectAxeButton_Click( object sender , RoutedEventArgs e ) => Aspect.Add(new Axe{Aspect=Aspect as Path.Aspect}.Set(Axes.Add)) ;
		void AddAspectTraitButton_Click( object sender , RoutedEventArgs e ) => Aspect.Trait.Add(new Aspect.Traitlet()) ;
		void AddAspectButton_Click( object sender , RoutedEventArgs e ) => Aspects.Add(new Aspect()) ;
		void AddAxeButton_Click( object sender , RoutedEventArgs e ) => Axes.Add(new Axe()) ;
		void SaveAspectsButton_Click( object sender , RoutedEventArgs e ) => Setup.AspectsPath.Set(p=>Aspects.Each(a=>p.Pathin(a.Spec).WriteAll((string)a))) ;
		void DisplayTable_SelectionChanged( object sender , SelectionChangedEventArgs e )
		{
			var tab = e.AddedItems.Count>0 ? e.AddedItems[0] as TabItem : null ; switch( tab?.Header as string )
			{
				case "Aspect" : Aspect = AspectsGrid.SelectedItem as Aspect ; ViewType = "Aspect" ; break ;
				case "Spectrum" : Aspect = (((SpectrumTabs.SelectedItem as TabItem)?.Content as DataGrid)?.ItemsSource as Pathable??SpectrumTabs.ItemsSource.OfType<Pathable>().One())?.Spectrum ; ViewType = "Spectrum" ; break ;
				case "Quantile" : ViewType = "Quantile" ; break ;
				case "Graph" : ViewPanel = GraphPanel ; break ;
				case "Map" : ViewPanel = MapPanel ; break ;
			}
		}
		void DataGridDeleteCommandBinding_Executed( object sender , ExecutedRoutedEventArgs e ) => ((sender as DataGrid)?.ItemsSource as IList).Set(l=>(sender as DataGrid)?.SelectedItems.OfType<object>().ToArray().Each(l.Remove)) ;
		#region Graphing
		void Graph_Draw( object sender , RoutedEventArgs e = null ) { ViewPanel = GraphPanel ; GraphPanel.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : GraphDrawAspect() ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		void Map_Draw( object sender , RoutedEventArgs e = null ) { ViewPanel = MapPanel ; MapPanel.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : MapDrawAspect() ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		string ViewType ; Canvas ViewPanel ; Dictionary<string,AxedEnumerable> QuantileData = new Dictionary<string,AxedEnumerable>() ;
		(double Width,double Height) MainFrameSize => (MainFrame.ColumnDefinitions[1].ActualWidth-ViewScreenBorder.Width,MainFrame.RowDefinitions[1].ActualHeight-ViewScreenBorder.Height) ;
		void GraphDrawAspect()
		{
			var axes = AspectAxisGrid.SelectedItems.OfType<Axe>().ToArray() ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 || !( AspectAxisGrid.SelectedItem is Axe xaxe ) ) return ;
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var rng = new Dictionary<string,(double Min,double Max)>() ; var sources = SourcesGrid.SelectedItems.Count>0 ? SourcesGrid.SelectedItems.OfType<Aspect>() : Sources ;
			sources.SelectMany(s=>s).Each(a=>{if(a.Any(q=>q!=null))if(!rng.ContainsKey(a.Spec))rng[a.Spec]=(a.Min().Value,a.Max().Value);else{rng[a.Spec]=(Math.Min(rng[a.Spec].Min,a.Min().Value),Math.Max(rng[a.Spec].Max,a.Max().Value));}}) ; if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v ) => axe.Binder.No() ? Format(v) : axb.Of(v) ;
				for( var m=0 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20);}) ) ;
				for( var m=50 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes) )
				{
					var y = rng[ax] ; axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=height-50 ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			foreach( var asp in sources )
			{
				var xax = asp[xaxe.Spec] ; var color = new SolidColorBrush(Colos[BookGrid.SelectedItems.IndexOf(asp.Raw)%Colos.Length]) ;
				foreach( var ax in asp ) if( yaxes.Contains(ax.Spec) ) try
				{
					var ptss = new List<(int Count,int From)>() ; { int c,i ; for( i=0 , c=0 ; i<ax.Count ; ++i ) if( xax[i]!=null&&ax[i]!=null ) ++c ; else { if( c>0 ) ptss.Add((c,i-c)) ; c = 0 ; } if( c>0 ) ptss.Add((c,i-c)) ; }
					foreach( var pts in ptss ) GraphPanel.Children.Add( new Polyline{
						Stroke = color , StrokeDashArray = Array.IndexOf(yaxes,ax.Spec).Get(j=>j<1?null:new DoubleCollection{j}) ,
						Points = new PointCollection(pts.Count.Steps(pts.From).Select(i=>ScreenPoint(((xax[i].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0)+asp.Offset,height-(ax[i].Value-rng[ax.Spec].Min)/(rng[ax.Spec].Max-rng[ax.Spec].Min).nil()*height??0)))
					} ) ;
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ;
			var co = Coordinates.ToDictionary(c=>c.Axe) ; Coordinates.Clear() ; Hypercube.Each(e=>Coordinates+=co.By(e.Key).Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
		}
		void MapDrawAspect()
		{
			var axes = AspectAxisGrid.SelectedItems.OfType<Axe>().ToArray() ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 || !( AspectAxisGrid.SelectedItem is Axe xaxe ) ) return ;
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var rng = new Dictionary<string,(double Min,double Max)>() ; var sources = SourcesGrid.SelectedItems.Count>0 ? SourcesGrid.SelectedItems.OfType<Aspect>() : Sources ;
			sources.SelectMany(s=>s).Each(a=>{if(a.Any(q=>q!=null))if(!rng.ContainsKey(a.Spec))rng[a.Spec]=(a.Min().Value,a.Max().Value);else{rng[a.Spec]=(Math.Min(rng[a.Spec].Min,a.Min().Value),Math.Max(rng[a.Spec].Max,a.Max().Value));}}) ; if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v , int p ) => axe.Binder.No() ? Format(v,p) : axb.Of(v) ;
				for( var m=0 ; m<=width ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20);}) ) ;
				for( var m=50 ; m<=width ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; MapPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes.Take(1)) )
				{
					var y = rng[ax] ;  axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=height-50 ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			(double X,double Y) sha = ((Coordinates.FirstOrDefault(c=>c.Axe==xaxe.Spec)?.Info??State.Coordination(xaxe.Spec)).Evaluate()??0,(Coordinates.FirstOrDefault(c=>c.Axe==yaxes[0])?.Info??State.Coordination(yaxes[0])).Evaluate()??0) ;
			double zis = Math.Pow(Math.Sqrt(width*height),1D/3D) ; var shift = 0 ; var zi = Setup.PrimaryShape ;
			foreach( var asp in sources )
			{
				var xax = asp[xaxe.Spec] ; var yax = asp[yaxes[0]] ;
				var pts = new List<(System.Windows.Point A,System.Windows.Point B,bool S,double? X,double? Y,(string Spec,double? Val)[] Z)>() ;
				for( int i=0 , c = asp.Points.Count-1 ; i<c ; ++i ) if( xax[i]!=null && yax[i]!=null && xax[i+1]!=null && yax[i+1]!=null && !asp.Points[i].Mark.HasFlag(Mark.Stop) ) try
				{
					var spt0 = ScreenPoint((xax[i].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0,height-(yax[i].Value-rng[yax.Spec].Min)/(rng[yax.Spec].Max-rng[yax.Spec].Min).nil()*height??0) ;
					var spt1 = ScreenPoint((xax[i+1].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0,height-(yax[i+1].Value-rng[yax.Spec].Min)/(rng[yax.Spec].Max-rng[yax.Spec].Min).nil()*height??0) ;
					if( spt0.X>=0 && spt0.Y>=0 && spt1.X<=width && spt1.Y<=height ) pts.Add((spt0,spt1,asp.Points[i+1].Mark.HasFlag(Mark.Stop),xax[i],yax[i],yaxes.Skip(1).Select(z=>(z,asp[z][i])).ToArray())) ;
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				for( var i=1 ; i<yaxes.Length ; ++i ) rng[yaxes[i]]=(pts.Min(p=>p.Z[i-1].Val).Value,pts.Max(p=>p.Z[i-1].Val).Value) ;
				var color = Colos[BookGrid.SelectedItems.IndexOf(asp.Raw)%Colos.Length] ; (double dx,double dy) lv = (0,0) ;
				foreach( var (A,B,S,X,Y,Z) in pts ) try
				{
					var za = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)).ToArray() ; var zb = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)?.Info??State.Coordination(z.Spec)).ToArray() ;
					var zicol = Z.At((zi+1)%2).nil(z=>z.Spec==null) ; var ziaro = Z.At(zi%2).nil(z=>z.Spec==null) ;
					var axcol = zicol.Get(z=>(z.Val-(zb.At((zi+1)%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At((zi+1)%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					var axaro = ziaro.Get(z=>(z.Val-(zb.At(zi%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At(zi%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					if( axcol<zb.At((zi+1)%2)?.Count-za.At((zi+1)%2)?.Size || axaro<zb.At(zi%2)?.Count-za.At(zi%2)?.Size ) continue ;
					var zisc = axcol==null && zicol?.Spec is string sp ? rng[sp].Min : zis ;
					var axarow = ziaro.use(z=>(axaro*zisc%zisc).Signate(zb.At(zi%2)?.Reverse==false?zisc:null as double?)??rng[z.Spec].Min) ;
					double x1 = A.X+shift*sha.X , y1 = A.Y+shift*sha.Y , x2 = B.X+shift*sha.X , y2 = B.Y+shift*sha.Y , ln = Math.Sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)) ; if( ln>0 ) lv = ((x2-x1)/ln,(y2-y1)/ln) ;
					MapPanel.Children.Add( new Line{ X1 =  x1, Y1 = y1 , X2 = x2 , Y2 = y2 ,
						Stroke = axcol.Get(z=>new SolidColorBrush(color*(float)(z%1).Signate(zb.At((zi+1)%2)?.Reverse==false?1:null as double?))) ?? new SolidColorBrush(color) ,
						StrokeThickness = axarow ?? ( axcol==null && (zicol?.Spec??ziaro?.Spec) is string spec ? rng[spec].Min : 1 ) ,
					} ) ;
					if( S ) MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-lv.dy*zis , Y2 = y2+lv.dx*zis , Stroke = Brushes.Black , StrokeThickness = 1 } ) ;
					if( axcol>zb.At((zi+1)%2)?.Count || axaro>zb.At(zi%2)?.Count )
					{
						foreach( var v in Z ) Coordinates.FirstOrDefault(c=>c.Axe==v.Spec).Set(c=>c.Value=v.Val) ;
						Coordinates.FirstOrDefault(c=>c.Axe==xax.Spec).Set(c=>c.Value=X) ; Coordinates.FirstOrDefault(c=>c.Axe==yax.Spec).Set(c=>c.Value=Y) ;
						break ;
					}
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				++shift ;
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			Hypercube.Each(e=>Coordinates+=co[e.Key].FirstOrDefault().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
		}
		void GraphDrawQuantile()
		{
			var axes = AspectAxisGrid.SelectedItems.OfType<Axe>().ToArray() ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; var selasps = SourcesGrid.SelectedItems.Null(s=>s.Count<=0) ;
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=127,G=127,B=127}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var rng = new List<KeyValuePair<string,(double Min,double Max)>>() ;
			var k = 0 ; if( Aspect!=null ) foreach( var axe in Aspect ) if( axe.Spec!=null && QuantileData.At(axe.Spec) is AxedEnumerable ax && ax.Count()>0 && yaxes.Contains(axe.Spec) )
			{
				var axa = ax.Ax ; Filter.Entry.Binding axb = axa.Binder ; string format( double v ) => (axa?.Binder).No() ? Format(v) : axb.Of(v) ;
				var val = ax.SelectMany(v=>v.Skip(1)) ; ((double Min,double Max) x,(double Min,double Max) y) = ((ax.Min(a=>a[0]),ax.Max(a=>a[0])),(val.Min(),val.Max())) ;
				rng.Add(new KeyValuePair<string,(double Min,double Max)>(ax.Ax.Spec,x)) ; rng.Add(new KeyValuePair<string,(double Min,double Max)>($"Q({ax.Ax.Spec}){ax.Axon?.Spec}",y)) ;
				{
					for( var m=0 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20-10*k);}) ) ;
					for( var m=50 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10+10*k);}) ) ;
					axa = ax.Axon ; axb = ax.Axon?.Binder ; for( var m=height-50 ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,-4);}) ) ;
					if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
				for( int j = 1 , cnt = ax.FirstOrDefault()?.Length??0 ; j<cnt ; ++j ) GraphPanel.Children.Add( new Polyline{
					Stroke = new SolidColorBrush( Colos[(selasps?[j-1] is Aspect asp?BookGrid.SelectedItems.IndexOf(asp.Raw):j-1)%Colos.Length] ) , StrokeDashArray = k==0?null:new DoubleCollection{k} ,
					Points = new PointCollection(ax.Select(a=>ScreenPoint((a[0]-x.Min)/(x.Max-x.Min)*width,height-(a[j]-y.Min)/(y.Max-y.Min)*height)))
				} ) ;
				++k ;
			}
			Hypercube = rng ; var co = Coordinates.ToDictionary(c=>c.Axe) ; Coordinates.Clear() ;
			rng.Each(e=>Coordinates+=co.By(e.Key).Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder}) ;
		}
		#endregion
		static int DecDigits( double value , int prec = 3 ) => value==0 ? 0 : (int)Math.Max(0,prec-Math.Log10(Math.Abs(value))) ;
		static string Format( double value , int prec = 3 ) => value.ToString("#."+new string('#',DecDigits(value,prec))) ;
		IEnumerable<KeyValuePair<string,(double Min,double Max)>> Hypercube ; (double Width,double Height) ViewFrame ; (Line X,Line Y) MouseCross , ScreenCross ;
		(double Width,double Height) ViewScreenBorder => (DisplayTable.Margin.Left+DisplayTable.Margin.Right+4,30) ;
		static readonly Color[] Colos = new[]{ new Color{A=255,R=255,G=0,B=0} , new Color{A=255,R=0,G=255,B=0} , new Color{A=255,R=0,G=0,B=255} , new Color{A=255,R=191,G=191,B=0} , new Color{A=255,R=0,G=191,B=191} , new Color{A=255,R=191,G=0,B=191} , new Color{A=255,R=223,G=0,B=159} , new Color{A=255,R=159,G=223,B=0} , new Color{A=255,R=0,G=159,B=223} , new Color{A=255,R=159,G=191,B=223} , new Color{A=255,R=223,G=159,B=0} , new Color{A=255,R=0,G=223,B=159} } ;
		void AspectAxisGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; }
		void AspectMultiToggle_Changed( object sender , RoutedEventArgs e ) { if( sender==AspectMultiToggle || AspectMultiToggle.IsChecked==true ) Sources = null ; }
		#region Coordinates
		void Main_MouseMove( object sender , MouseEventArgs e ) => MousePoint = Mouse.GetPosition(ViewPanel) ;
		public class Coordinate : INotifyPropertyChanged
		{
			Main Context ;
			public event PropertyChangedEventHandler PropertyChanged ;
			public Coordinate( Main context , string axe ) => Info = (_byte = (Context = context).State[Axe = axe]).ParseCoinfo() ;
			public string Axe { get; }
			public double? Value { get => value ; internal set { this.value = value ; PropertyChanged.On(this,"Value,View") ; } } double? value ;
			public string View => Binding.Of(value) ;
			public string Byte { get => _byte ; set { if( Byte==value ) return ; Context.State[Axe] = _byte = value ; Info = value.ParseCoinfo() ; PropertyChanged.On(this,"Byte") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; } } string _byte ;
			public (double? Byte,uint? Count,bool Reverse)? Info { get => info ?? Context.State.Coordination(Axe) ; set { if( info.Equals(value) ) return ; info = value ; Byte = value.StringCoinfo() ; } } (double? Byte,uint? Count,bool Reverse)? info ;
			public (double Min,double Max) Range ;
			public string Bond { set => Binding = value ; } Filter.Entry.Binding Binding ;
			public string At { get => at ; set { if( value==at ) return ; Size = (at=value).Parse<uint>() ; PropertyChanged.On(this,"At") ; } } string at ;
			public uint? Size { get =>size ; set { if( value==size ) return ; size = value ; PropertyChanged.On(this,"Size") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; At = value.Stringy() ; } } uint? size ;
		}
		public Aid.Collections.ObservableList<Coordinate> Coordinates { get; private set; } = new Aid.Collections.ObservableList<Coordinate>() ;
		public System.Windows.Point? MousePoint
		{
			get => mousePoint ; set
			{
				MouseCross.X.Set(ViewPanel.Children.Remove) ; MouseCross.Y.Set(ViewPanel.Children.Remove) ; if( value==null || value?.X<0 || value?.Y<0 || value?.X>ViewFrame.Width || value?.Y>ViewFrame.Height ) return ;
				var asp = Hypercube is Array ; PropertyChanged.On( this, "MousePoint", (mousePoint=value).Use(m=>Hypercube.Each(a=>CoordinateSet(m,a,asp))) ) ;
				ViewPanel.Children.Add( MouseCross.X = new Line{ Stroke=Brushes.Gray , X1=0 , X2=ViewFrame.Width , Y1=value.Value.Y , Y2=value.Value.Y } ) ;
				ViewPanel.Children.Add( MouseCross.Y = new Line{ Stroke=Brushes.Gray , Y1=0 , Y2=ViewFrame.Height , X1=value.Value.X , X2=value.Value.X } ) ;
			}
		}
		void CoordinateSet( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a , bool asp )
		{
			var co = Coordinates.First(c=>c.Axe==a.Key) ; co.Value = ( asp ? AspectAxisGrid.SelectedItem is Axe x && a.Key==x.Spec : !a.Key.StartsBy("Q(") ) ?
			ScreenX(AxeXByMouse(m,a),a.Value) : ViewPanel==GraphPanel || Coordinates.IndexOf(co)<2 ? ScreenY(AxeYByMouse(m,a),a.Value) : AxeZByMouse(a.Key) ;
		}
		double AxeXByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => m.X/ViewFrame.Width*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double AxeYByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => (ViewFrame.Height-m.Y)/ViewFrame.Height*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double? AxeZByMouse( string a )
		{
			var x = Coordinates[0]?.Value ; var y = Coordinates[1]?.Value ; var ax = Coordinates[0]?.Axe ; var ay = Coordinates[1]?.Axe ; Aspect.Point? op = null ; double? ov = null , cv = null ;
			foreach( var src in Sources ) foreach( var pt in src.Points ) if( (cv=(pt[ax]-x).Sqr()+(pt[ay]-y).Sqr())<ov || ov==null ) { op = pt ; ov = cv ; }
			return op?[a] ;
		}
		#endregion
		#region Focusing
		System.Windows.Point? mousePoint , screenPoint ; System.Windows.Rect? ScreenRect ;
		System.Windows.Point? ScreenOrigin
		{
			get => screenPoint ; set
			{
				ScreenCross.X.Set(ViewPanel.Children.Remove) ; ScreenCross.Y.Set(ViewPanel.Children.Remove) ; var p = ScreenMouse ; screenPoint = value.Get(v=>p) ; if( value==null ) return ;
				ViewPanel.Children.Add( ScreenCross.X = new Line{ Stroke=Brushes.Orange , X1=0 , X2=ViewFrame.Width , Y1=value.Value.Y , Y2=value.Value.Y } ) ;
				ViewPanel.Children.Add( ScreenCross.Y = new Line{ Stroke=Brushes.Orange , Y1=0 , Y2=ViewFrame.Height , X1=value.Value.X , X2=value.Value.X } ) ;
			}
		}
		System.Windows.Point? ScreenMouse { get { if( ScreenRect==null || MousePoint==null ) return MousePoint ; (var width,var height) = MainFrameSize ; var p = MousePoint.Value ; var r = ScreenRect.Value ; return new System.Windows.Point(p.X*r.Size.Width/width+r.Location.X,p.Y*r.Size.Height/height+r.Location.Y) ; } }
		void ViewPanel_MouseDown( object sender, MouseButtonEventArgs e ) => ScreenOrigin = MousePoint ;
		void DisplayTable_MouseUp( object sender, MouseButtonEventArgs e ) { if( ScreenMouse==ScreenOrigin ) return ; var scr = ScreenOrigin.Get(s=>ScreenMouse.use(p=>new Rect(s,p))) ; if( scr==ScreenRect ) return ; ScreenRect = scr ; if( GraphTab.IsSelected ) Graph_Draw(sender) ; if( MapTab.IsSelected ) Map_Draw(sender) ; }
		void DisplayTable_MouseDoubleClick( object sender, MouseButtonEventArgs e ) { var draw = ScreenRect!=null ; ScreenOrigin = null ; ScreenRect = null ; if( draw ) if( GraphTab.IsSelected ) Graph_Draw(sender,e) ; else if( MapTab.IsSelected ) Map_Draw(sender,e) ; }
		System.Windows.Point ScreenPoint( double x , double y ) => new System.Windows.Point(ScreenX(x),ScreenY(y)) ;
		double ScreenX( double x ) { if( ScreenRect==null ) return x ; var r = ScreenRect.Value ; return (x-r.Location.X)*ViewFrame.Width/r.Size.Width ; }
		double ScreenY( double y ) { if( ScreenRect==null ) return y ; var r = ScreenRect.Value ; return (y-r.Location.Y)*ViewFrame.Height/r.Size.Height ; }
		double ScreenX( double x , (double Min,double Max) e ) { if( ScreenRect==null ) return x ; var r = ScreenRect.Value ; var q = (e.Max-e.Min)/ViewFrame.Width ; var fx = (x-e.Min)/q ; return e.Min+r.Location.X*q+fx*r.Width/ViewFrame.Width*q ; }
		double ScreenY( double y , (double Min,double Max) e ) { if( ScreenRect==null ) return y ; var r = ScreenRect.Value ; var q = (e.Max-e.Min)/ViewFrame.Height ; var fy = (e.Max-y)/q ; return e.Max-r.Location.Y*q-fy*r.Height/ViewFrame.Height*q ; }
		#endregion
		#region Stepping
		void Coordinates_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.001) ;
		void Coordinates_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.001) ;
		void Coordinates_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.01) ;
		void Coordinates_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.01) ;
		void Coordinates_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.1) ;
		void Coordinates_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.1) ;
		void Coordinates_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(.001) ;
		void Coordinates_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(null) ;
		void Coordinates_CountLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-1) ;
		void Coordinates_CountRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+1) ;
		void Coordinates_CountUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-10) ;
		void Coordinates_CountDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+10) ;
		void Coordinates_CountPageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-100) ;
		void Coordinates_CountPageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+100) ;
		void Coordinates_CountHome_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(0) ;
		void Coordinates_CountEnd_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(null) ;
		void Coordinates_AtLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(-1) ;
		void Coordinates_AtRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(+1) ;
		void Coordinates_AtUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(1) ;
		void Coordinates_AtDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(null) ;
		void CoordinatesMove( double step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(Math.Max(.001*(c.Range.Max-c.Range.Min),(i.Byte+step*(c.Range.Max-c.Range.Min))??c.Range.Max-c.Range.Min),i.Count,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSet( double? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(state*(c.Range.Max-c.Range.Min),i.Count is uint m?state is double s?s==0?i.Count:Math.Min((uint)((c.Range.Max-c.Range.Min)/s),m):1U:null as uint?,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(i.Byte,i.Count.use(v=>(uint)Math.Min(i.Byte is double b?(c.Range.Max-c.Range.Min)/b:1,Math.Max(0,(int)v+step))),i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(i.Byte,state,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=c.Size.use(a=>(uint)Math.Max(0,(int)a+step))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=state) ; GridFocusHold(CoordinatesGrid,sel) ; }
		#endregion
		async void GridFocusHold( DataGrid grid , IEnumerable<object> sel ) { await Task.Delay(10) ; sel.Each(s=>grid.SelectedItems.Add(s)) ; grid.Focus() ; }
		#region Drifting
		void Source_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-1) ;
		void Source_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+1) ;
		void Source_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<5)) ;
		void Source_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<5)) ;
		void Source_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<10)) ;
		void Source_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<10)) ;
		void Source_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(0) ;
		void Source_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(MainFrameSize.Width) ;
		void SourceDriftMove( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset+=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		void SourceDriftSet( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		#endregion
	}
	public class QuantileSubversion : IMultiValueConverter
	{
		public object Convert( object[] values , Type targetType , object parameter , CultureInfo culture )
		{
			if( values.At(0) is Axe ax && values.At(1) is IEnumerable<Aspect> src );else return null ;
			var srcf = (values.At(3) as IEnumerable)?.OfType<Aspect>().Null(v=>v.Count()<=0) ; var srcs = (srcf??src).Where(a=>a[ax.Spec]!=null) ;
			var dis = (ax.Distribution??srcs.SelectMany(s=>s[ax.Spec].Distribution??Enumerable.Empty<double>()).Distinct().OrderBy(v=>v)).ToArray() ;
			var axon = values.At(2) as Axe ; var res = srcs.Select(a=>a[ax.Spec].Quantile[dis,a[axon?.Spec]].ToArray()).ToArray() ;
			try { return new AxedEnumerable{ Ax = ax , Axon = axon , Content = res.Length>0 && res[0].Length>0 ? res[0].Length.Steps().Select(i=>res.Length.Steps().Select(j=>res[j][i]).Prepend(dis[i+(dis.Length>res[0].Length?1:0)]).ToArray()) : Enumerable.Empty<double[]>() } ; }
			catch( System.Exception e ) { Trace.TraceWarning(e.Stringy()) ; return new AxedEnumerable{ Ax = ax , Axon = axon , Content = Enumerable.Empty<double[]>() } ; }
		}
		public object[] ConvertBack( object value , Type[] targetTypes , object parameter , CultureInfo culture ) => null ;
	}
	public class TraitConversion : IValueConverter
	{
		public static TraitConversion The = new TraitConversion() ; static readonly IDictionary<string,Filter.Entry.Binding> Binder = new Dictionary<string,Filter.Entry.Binding>() ;
		Filter.Entry.Binding Bind( string form ) => Binder.TryGetValue(form??string.Empty,out var v) ? v : Binder[form??string.Empty] = form ;
		public object Convert( object value , Type targetType , object parameter , CultureInfo culture ) => value is Aspect.Traits t ? t[(int)parameter].Get(r=>Bind(r.Bond).Of(r.Value)) : null ;
		public object ConvertBack( object value , Type targetType , object parameter , CultureInfo culture ) => null ;
	}
	struct AxedEnumerable : IEnumerable<double[]> { public Axe Ax , Axon ; internal IEnumerable<double[]> Content ; public IEnumerator<double[]> GetEnumerator() => Content?.GetEnumerator()??Enumerable.Empty<double[]>().GetEnumerator() ; IEnumerator IEnumerable.GetEnumerator() => GetEnumerator() ; }
	public class Filter : Aid.Collections.ObservableList<Filter.Entry>
	{
		public class Entry
		{
			const string Separator = " \x1 Filet \x2 " ;
			public bool Rex { get => rex && !Filter.Void() ; set => rex = value ; } bool rex ;
			public string Filter { get => filter ; set { if( (value=value.Null(v=>v.Void()))==filter ) return ; filter = value ; Dirty = true ; } } string filter ;
			public string Traits { get => traits ; set { if( (value=value.Null(v=>v.Void()))==traits ) return ; traits = value ; Dirty = true ; } } string traits ;
			public string Matrix { get => matrix ; set { if( (value=value.Null(v=>v.Void()))==matrix ) return ; matrix = value ; Dirty = true ; } } string matrix ;
			public string Associer { get => associer ; set { if( (value=value.Null(v=>v.Void()))==associer ) return ; associer = value ; Dirty = true ; } } string associer ;
			public string Matter { get => matter ; set { if( (value=value.Null(v=>v.Void()))==matter ) return ; matter = value ; Dirty = true ; } } string matter ;
			public bool Dirty ;
			public static explicit operator string( Entry entry ) => entry.Get(e=>string.Join(Separator,e.Rex?" ":string.Empty,e.Filter,e.Traits,e.Matrix,e.Associer,e.Matter)) ;
			public static implicit operator Entry( string entry ) => entry.Get(e=>{ var f = e.Separate(Separator) ; return f.Length<=1 ? null : new Entry{ rex = f[0]==" " , filter = f.At(1) , traits = f.At(2) , matrix = f.At(3) , associer = f.At(4) , matter = f.At(5) } ; }) ;
			public Predicate<Objective> ToFilter<Objective>() => Rex ? new System.Text.RegularExpressions.Regex(Filter).Get(r=>new Predicate<Objective>(o=>r.Match(o?.ToString()).Success)) : Filter.Compile<Predicate<Objective>>() ;
			public Predicate<Objective> ToAssocier<Objective>() => Associer.Compile<Predicate<Objective>>() ;
			public (Predicate<Objective> Filter,Predicate<Enhancer> Associer) ToRefiner<Objective,Enhancer>() => (ToFilter<Objective>(),ToAssocier<Enhancer>()) ;
			public struct Binding
			{
				public string Path , Name , Format , Align ; public IValueConverter Converter ; 
				public string Form => Align.No() ? Format : Format.No() ? $"{{0,{Align}}}" : $"{{0,{Align}:{Format}}}" ;
				public string Reform => Align.No()&&!Format.No() ? $"{{0:{Format}}}" : Form ;
				public static implicit operator Binding( string value ) => new Binding(value) ;
				public Binding( string value )
				{
					if( value?.TrimStart().StartsBy("(")==true ) { var cvt = value.LeftFromScoped(true,'/',',',':') ; Converter = new Aid.Converters.LambdaConverter{Forward=cvt} ; Path = null ; value = value.RightFromFirst(cvt) ; } else { Path = value.LeftFrom(true,':',',','/') ; Converter = null ; }
					Name = value.LeftFrom(true,':',',').RightFromFirst('/',true) ; Format = value.RightFromFirst(':') ; Align = value.LeftFrom(':').RightFrom(',') ;
				}
				public string Of( object value ) => Reform.Form( Converter is IValueConverter c ? c.Convert(value,null,null,null) : value ) ;
			}
		}
		const string Separator = " \x1 Filter \x2\n" ;
		public static explicit operator string( Filter filter ) => filter.Get(f=>string.Join(Separator,f.Where(e=>!e.Filter.Void()).Select(e=>(string)e+Separator))) ;
		public static implicit operator Filter( string filter ) => filter.Get(f=>new Filter{Sensible=true}.Set(t=>f.Separate(Separator).Each(e=>t.Add(e)))) ;
	}
	public struct Associable { public Pathable Path ; public Aspect Aspect ; public Associable( Pathable path , Aspect aspect ) { Path = path ; Aspect = aspect ; } public  static implicit operator Associable( (Pathable path,Aspect aspect) arg ) => new Associable(arg.path,arg.aspect) ; }
}
