using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.ComponentModel;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Diagnostics;
using Microsoft.Win32;
using Aid.Extension;
using System.Collections.Specialized;
using System.Globalization;
using Aid.IO;

namespace Rob.Act.Analyze
{
	using Book = Gen.Book ;
	/// <summary>
	/// Interaction logic for MainWindow.xaml
	/// </summary>
	public partial class Main : Window , INotifyPropertyChanged
	{
		public static Settings Setup => setup?.Result ; static readonly Aid.Prog.Setup<Settings> setup ;
		static Main() { AppDomain.CurrentDomain.Load(typeof(Translation).Assembly.FullName) ; new Aid.Prog.Setup(e=>Trace.TraceError($"Setup {e}")).Go() ; setup = (Resetup,e=>Trace.TraceError($"Setup Settings {e}")) ; Doct = (Setup.Doctee.Uri(),e=>Trace.TraceError($"Doctor {e}")) ; }
		static Aid.Prog.Doct Doct ;
		public static readonly Aspect Laboratory = new Aspect() ;
		readonly Presources Presources ;
		static void Resetup( Settings past )
		{
			if( Doct?["Main"] is Main main );else return ;
			if( Setup?.ActionTraits?.Equates(past?.ActionTraits)==false ) main.Dispatcher.Invoke(()=>main.BookGrid_AutoGeneratedColumns(main.BookGrid)) ;
			if( Setup?.SpectrumBinds?.Equates(past?.SpectrumBinds)==false ) main.Book.Each(p=>p.Spectrum.Reform(Setup.SpectrumBinds)) ;
			if( Setup?.SubjectMass.Equates(past?.SubjectMass)==false ) Basis.Mass = Setup.SubjectMass ;
		}
		public State State { get => state ; private set => state = (value??new State()).Set(s=>s.Context=this) ; } State state ;
		FileSystemWatcher[] WorkoutsWatchers ;
		public event PropertyChangedEventHandler PropertyChanged ;
		void PropertyChangedOn<Value>( string properties , Value value ) => Dispatcher.Invoke(()=>{ PropertyChanged.On(this,properties,value) ; if( properties.Consists("Sources") ) if( GraphTab.IsSelected ) Graph_Draw(this) ; else if( MapTab.IsSelected ) Map_Draw(this) ; } ) ;
		public Main()
		{
			InitializeComponent() ; Presources = new Presources(BookGrid,this) ; AppDomain.CurrentDomain.Load(typeof(AxeOperations).Assembly.FullName) ; ViewPanel = GraphPanel ; DataContext = this ;
			Doct += (this,"Main") ; Aspectables.The = (()=>Book.Entries.Select(p=>p.Spectrum).Union(Aspects.Entries),()=>Aspects.Entries) ; SourcesGrid.ItemContainerGenerator.ItemsChanged += SourcesGrid_ItemsChanged ; Task.Factory.StartNew(Load) ;
		}
		void Load()
		{
			Setup.Altiplane.nil(a=>a.Grade==0).Use(g=>{
				Path.Altiplanes = new List<Path.Altiplane>() ;
				foreach( var a in System.IO.Directory.GetFiles(Setup.StatePath,$"{Altiplane.FileSign}*{Path.Altiplane.ExtSign}") ) { Trace.TraceInformation($"Loading {a}") ; Path.Altiplanes.Add(new Path.Altiplane(a){Radius=g.Radius}) ; }
				if( Path.Altiplanes.Count==0 ) Path.Altiplanes.Add(new Path.Altiplane(g.Grade,g.Grane){Radius=g.Radius}) ;
			}) ;
			Setup.WorkoutsPaths.SeparateTrim(',').SelectMany(l=>l.MatchingFiles()).EachGuard(f=>{Trace.TraceInformation($"Loading {f}");NewAction(f,Setup?.WorkoutsFilter);},(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			Setup.AspectsPaths.SeparateTrim(',').SelectMany(l=>l.MatchingFiles()).EachGuard(f=>{Trace.TraceInformation($"Loading {f}");NewAspect(f,Setup?.AspectsFilter);},(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			WorkoutsWatchers = Setup.WorkoutsPaths.SeparateTrim(',').Select(l=>new FileSystemWatcher(l){EnableRaisingEvents=true}.Set(w=>{ w.Edited += NewAction ; w.Deleted += (s,a)=>Book-=p=>p.Origin==a.FullPath ; })).ToArray() ;
			State = new State{ Context = this } ;
		}
		protected override void OnClosing( CancelEventArgs e ) { Doct?.Dispose() ; base.OnClosing(e) ; }
		protected override void OnClosed( EventArgs e ) { base.OnClosed(e) ; Process.GetCurrentProcess().Kill() ; }
		void NewAction( string file , Predicate<Pathable> filter = null ) => file.Reconcile().Internalize().Set(p=>p.Origin=file).Set(Translation.Partitionate).Set(p=>p.Spectrum.Reform(Setup.SpectrumBinds)).Set(p=>{Book|=(filter as Predicate<Pathable>)?.Invoke(p)!=false?p:null;if(Book.Contains(p)){ActionEnhancing(p,ActiveRefiner);Dispatcher.Invoke(SaveBook);}}) ;
		void NewAction( object subject , System.IO.FileSystemEventArgs arg ) => NewAction(arg.FullPath,Setup?.WorkoutsFilter) ;
		void NewAspect( string file , Predicate<Aspect> filter = null ) => ((Aspect)file.ReadAllText()).Set(a=>a.Origin=file).Set(a=>Aspects+=(filter as Predicate<Aspect>)?.Invoke(a)!=false?a:null) ;
		public Book Book { get ; private set ; } = new Book("Main") ;
		public Filter ActionFilter { get => actionFilter ; internal set { if( value==actionFilter ) return ; actionFilter = value ; PropertyChanged.On(this,"ActionFilter") ; } } Filter actionFilter ;
		public Filter SourceFilter { get => sourceFilter ; internal set { if( value==sourceFilter ) return ; sourceFilter = value ; PropertyChanged.On(this,"SourceFilter") ; } } Filter sourceFilter ;
		public Filter AspectFilter { get => aspectFilter ; internal set { if( value==aspectFilter ) return ; aspectFilter = value ; PropertyChanged.On(this,"AspectFilter") ; } } Filter aspectFilter ;
		string[] ActionTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Traits.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.ActionTraits ;
		string[] MatrixTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Matrix.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.MatrixTraits?.Concat(BookGrid.SelectedItems.OfType<Path>().SelectMany(p=>p.Metax?.Bonds??Enumerable.Empty<string>()).Distinct()).ToArray() ;
		internal bool BlockSourcesUpdate ; void ActionFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e )
		{
			Presources.Snapshot() ; using( new Aid.Closure(()=>BlockSourcesUpdate=true,()=>BlockSourcesUpdate=false) )
				FilterGrid_SelectionChanged<Pathable,Associable>(sender,async a=>{Book.Refinement=a.Select(f=>(f.Filter,f.Query));BookGrid_AutoGeneratedColumns();Presources.Reselect();await Task.Factory.StartNew(()=>ActionsEnhancing(a));BookGrid_AutoGeneratedColumns();Presources.Reselect();}) ;
		}
		void SourceFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Aspect>(sender,f=>{Sourcer=f;Sources=sources;}) ;
		void AspectFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Aspect>(sender,f=>Aspects.Refinement=f) ;
		void FilterGrid_SelectionChanged<Objective>( object sender , Action<(Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>>)[]> doing ) => (sender as DataGrid)?.SelectedItems.OfType<Filter.Entry>().Select(f=>(f.ToFilter<Objective>(),f.ToQuery<Objective>())).ToArray().Set(doing) ;
		IEnumerable<(Func<Objective,bool> Filter,Func<Enhancer,bool> Associer,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)> Refiner<Objective,Enhancer>( DataGrid sender ) => sender.SelectedItems.OfType<Filter.Entry>().Select(f=>f.ToRefiner<Objective,Enhancer>()) ;
		(Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] ActiveRefiner ; Metax ActiveMetax ;
		void FilterGrid_SelectionChanged<Objective,Enhancer>( object sender , Action<(Func<Objective,bool> Filter,Func<Enhancer,bool> Associer,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)[]> doing )
		=> Refiner<Objective,Enhancer>(sender as DataGrid).ToArray().Set(r=>ActiveRefiner=r as (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[]).Set(doing) ;
		public Aid.Collections.ObservableList<Aspect>.Filtered Aspects { get ; private set ; } = new Aid.Collections.ObservableList<Aspect>.Filtered{Sensible=true} ;
		void ActionsEnhancing( params (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] refiner ) { ActiveMetax = null ; foreach( var path in Book.ToArray() ) ActionEnhancing(path,refiner) ; Dispatcher.Invoke(SaveBook) ; }
		void ActionEnhancing( Pathable path , params (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] refiner )
		{
			if( refiner==null || path==null ) return ; path.Spectrum.Trait.Clean() ;
			foreach( var refine in refiner ) if( refine.Filter?.Invoke(path)!=false ) foreach( var asp in Aspects.Entries ) if( (refine.Associer?.Invoke((path,asp))??(refine.Filter!=null?Setup.ActionAssocier?.Invoke(path,asp):false))==true )
				new Aspect(asp){Source=path.Spectrum}.Set(a=>{path.Spectrum.Trait.Add(a.Trait);path.Spectrum.Tager+=a.Tager;}) ;
			PathEnhancing(path as Path) ;
		}
		void PathEnhancing( Path path ) => path.Set(p=>p.Metax=ActiveMetax??(ActiveMetax=new Metax(p.Metax?.Base??p.Dimension)))?.Populate() ;
		void SaveBook() { if( ActionFilterGrid.SelectedItems.Count==1 && (ActionFilterGrid.SelectedItem as Filter.Entry)?.Matter.Null(v=>v.Void()) is string matter && Book.Count>0 && Setup?.WorkoutsPath is string path ) try{Book.Save(path,matter);}catch(System.Exception e){Trace.TraceError("Save Book failed on {0}:{1} : {2}",path,matter,e);} }

		#region Core
		public Aid.Collections.ObservableList<Axe> Axes { get ; private set ; } = new Aid.Collections.ObservableList<Axe>() ;
		/// <summary> Aspect is never null , either Spectrum , or aspect ready for projection . If without selection then set to <see cref="Laboratory"/> . </summary>
		public Aspect Aspect { get => Respect ; protected set { if( (value??Laboratory)==Aspect ) return ; Aspect.Set(a=>{a.CollectionChanged-=OnAspectChanged;a.PropertyChanged-=OnAspectChanged;}) ; (Respect=value??Laboratory).Set(a=>{a.CollectionChanged+=OnAspectChanged;a.PropertyChanged+=OnAspectChanged;}) ; AspectAxisGrid.CanUserAddRows = AspectAxisGrid.CanUserDeleteRows = AspectTraitsGrid.CanUserAddRows = AspectTraitsGrid.CanUserDeleteRows = AspectsGrid.SelectedItems.Count<=1 ; Resources = null ; PropertyChangedOn("Aspect",value) ; } } Aspect Respect = Laboratory ;
		public IEnumerable<Axe> Quantiles { get => quantiles??Enumerable.Empty<Axe>() ; private set { if( !quantiles.SequenceEquate(value) ) PropertyChangedOn("Quantiles",quantiles=value?.ToArray()) ; } } Axe[] quantiles ;
		public IEnumerable<Aspect> Sources { get => Resources.Issue(Sourcer) ; set => PropertyChangedOn("Sources",value) ; } (Func<Aspect,bool> Filter,Func<IEnumerable<Aspect>,IEnumerable<Aspect>> Query)[] Sourcer ;
		public new IEnumerable<Aspect> Resources { get => sources ??= new Aid.Collections.ObservableList<Aspect>(ActionsProjection) ; set { PropertyChangedOn("Resources", DrawingResources = sources = value ) ; Sources = value ; } } IEnumerable<Aspect> sources ;
		Aspect Projection( Pathable path ) => new Aspect(Aspect){Source=path.Spectrum} ;
		IEnumerable<Aspect> Projection( IEnumerable<Pathable> p ) => p.Select(Projection).ToArray().Reprojection() ;
		IEnumerable<Aspect> ActionsProjection => Presources.Get( p => Aspect is Path.Aspect ? p.Select(s=>s.Spectrum) : Projection(p) ) ;
		Aspect Resource( Pathable path ) => Aspect is Path.Aspect ? path.Spectrum : Projection(path) ;
		int SourceIndex( object item ) => item is Aspect asp ? Resources.IndexIf(a=>a==asp) is int i ? i : Presources.IndexOf(asp?.Raw) : item is Pathable path ? Resources.IndexIf(a=>a.Raw==path) is int j ? j : Presources.IndexOf(path) : -1 ;
		Color Coloring( object item ) => Coloring(SourceIndex(item)) ;
		#endregion

		void SourcesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => Sources = sources ;
		void AspectTraitsGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => new HashSet<string>(AspectTraitsGrid.SelectedItems.OfType<Aspect.Traitlet>().Select(t=>t.Spec)).Set(t=>SourcesGrid.Columns.Skip(1).Each(c=>c.Visibility=t.Contains(c.Header)?Visibility.Hidden:Visibility.Visible)) ;
		void CoordinatesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( MapTab.IsSelected ) Map_Draw(this) ; }
		void OnAspectChanged( object subject , NotifyCollectionChangedEventArgs arg=null ) { var sub = Aspect is Path.Aspect ? SpectrumTabs : AspectTabs ; Revoke : var six = sub.SelectedIndex ; if( sub==AspectTabs || sub==QuantileTabs ) Resources = null ; sub.SelectedIndex = -1 ; sub.SelectedIndex = six ; if( sub==AspectTabs ) { sub = QuantileTabs ; goto Revoke ; } }
		void OnAspectChanged( object subject , PropertyChangedEventArgs arg ) => OnAspectChanged(subject) ;
		async void BookGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( BlockSourcesUpdate ) return ; await Task.Factory.StartNew(()=>Resources_Update(e)) ; Grid_Coloring(sender) ; }
		void Resources_Update( SelectionChangedEventArgs e )
		{
			//if( Multiaspected ) { Sources = null ; return ; } // inoptimal solution
			if( sources is IList<Aspect> sl ); else return ;
			foreach( Pathable path in e.RemovedItems ) sl.IndexIf(a=>a.Raw==path).Use(sl.RemoveAt) ; foreach( Pathable path in e.AddedItems ) if( !sl.Any(a=>a.Raw==path) ) Resource(path).Set(sl.Add) ; // Individual aspect perspective update .
			if( !Aspect.Regular ) sl.Reprojection() ; // Update of multi-sources for each aspect .
			Resources = sources ;
		}
		async internal void Grid_Coloring( object sender ) { for( var success = RecolorGrid(sender)?0:10 ; success>0 ; success -= RecolorGrid(sender)?success:1 ) await Task.Delay(100) ; }
		bool RecolorGrid( object sender )
		{
			var success = true ; if( sender is DataGrid bg ); else return success ;
			var gen = bg.ItemContainerGenerator ; foreach( var item in bg.Items ) if( gen.ContainerFromItem(item) is DataGridRow row )
				if( row.Cell(0) is DataGridCell cell && cell.Foreground is SolidColorBrush b && Coloring(item) is Color c && b.Color!=c ) cell.Foreground = new SolidColorBrush(c) ; else success = false ;
			return success ;
		}
		void AspectGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; var pts = grid.ItemsSource as Aspect.Point.Iterable ; var asp = pts?.Context ; grid.Columns.Clear() ;
			uint i=0 ; foreach( var ax in asp ) { Filter.Entry.Binding b = ax.Binder ; var o = b.Converter==null||b.Name.No() ; grid.Columns.Add(new DataGridTextColumn{Header=o?ax.Spec:b.Name,Binding=new Binding(o?$"[{i}]":b.Path){StringFormat=b.Form,Converter=b.Converter}}) ; ++i ; }
			if( pts.Context.Raw?.Any(p=>p.Tags!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ; if( pts.Context.Raw?.Any(p=>p.Marklet!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Mark",Binding=new Binding("Marklet")}) ;
		}
		void QuantileGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; var src = Sources ; grid.Columns.Clear() ; if( grid.ItemsSource is Quantilable axe )
			{
				QuantileData[axe.Ax.Spec] = axe ; Filter.Entry.Binding b = axe.Ax.Binder , cb = axe.Axon?.Binder ;
				grid.Columns.Add(new DataGridTextColumn{Header=b.Of(axe.Ax.Distribution.One()),Binding=new Binding("[0]"){StringFormat=b.Form,Converter=b.Converter}}) ;
				uint i=1 ; foreach( var asp in src ) grid.Columns.Add(new DataGridTextColumn{Header=asp.Spec,Binding=new Binding($"[{i++}]"){StringFormat=cb.Form,Converter=cb.Converter}}) ;
			}
		}
		void SourcesGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; var asp = Aspect ; grid.Columns.Clear() ;
			grid.Columns.Add(new DataGridTextColumn{Header="Spec",Binding=new Binding("Spec")}) ; var f = new HashSet<string>(AspectTraitsGrid.SelectedItems.OfType<Aspect.Traitlet>().Select(t=>t.Spec)) ;
			int i=0 ; foreach( var tr in asp.Trait ) grid.Columns.Add(new DataGridTextColumn{Header=tr.Name,Binding=new Binding("Trait"){ConverterParameter=i++,Converter=TraitConversion.The},Visibility=f.Contains(tr.Spec)?Visibility.Hidden:Visibility.Visible}) ;
			if( asp.Taglet!=null ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ;
		}
		void BookGrid_AutoGeneratedColumns( object sender=null , EventArgs e=null ) => ConGrid_AutoGeneratedColumns(sender??BookGrid,ActionTraits) ;
		void MatrixGrid_AutoGeneratedColumns( object sender , EventArgs e=null ) => ConGrid_AutoGeneratedColumns(sender,MatrixTraits) ;
		void ConGrid_AutoGeneratedColumns( object sender , params string[] traits )
		{
			if( traits==null ) return ; var grid = sender as DataGrid ; grid.Columns.Clear() ;
			foreach( Filter.Entry.Binding tr in traits ) grid.Columns.Add(new DataGridTextColumn{Header=tr.Name,Binding=new Binding(tr.Path){Converter=tr.Converter,StringFormat=tr.Form}}) ;
		}
		async void SourcesGrid_ItemsChanged( object sender , System.Windows.Controls.Primitives.ItemsChangedEventArgs e )
		{
			var gen = sender as ItemContainerGenerator ; for( int i=0 , c=gen.Items.Count ; i<c ; ++i )
			try { var j=0 ; Retry: if( gen.ContainerFromIndex(i) is DataGridRow row ) row.Cell(0).Foreground = new SolidColorBrush(Coloring(gen.Items[i] as Aspect)) ; else { await Task.Delay(100) ; if( ++j<10 ) goto Retry ; } } catch {}
		}
		void AspectTabs_Selected( object sender , SelectionChangedEventArgs e )
		{
			var asp = e.AddedItems.Count>0 ? e.AddedItems[0] : null ; switch( (DisplayTable.SelectedItem as TabItem)?.Header )
			{
				case "Aspect" : Aspect = AspectSelection ; break ; case "Spectrum" : (asp as Pathable)?.Spectrum.Set(a=>Aspect=a) ; break ;
				case "Graph" : case "Map" : case "Quantile" : if( Aspect is Path.Aspect ) break ; else goto case "Aspect" ;
			}
		}

		#region Hidden
		void AddActionButton_Click( object sender , RoutedEventArgs e ) { var dlg = new OpenFileDialog{Multiselect=true} ; if( dlg.ShowDialog(this)==true ) dlg.FileNames.Each(f=>NewAction(f)) ; }
		void AddAspectAxeButton_Click( object sender , RoutedEventArgs e ) => Aspect.Add(new Axe{Aspect=Aspect as Path.Aspect}.Set(Axes.Add)) ;
		void AddAspectTraitButton_Click( object sender , RoutedEventArgs e ) => Aspect.Trait.Add(new Aspect.Traitlet()) ;
		void AddAspectButton_Click( object sender , RoutedEventArgs e ) => Aspects.Add(new Aspect()) ;
		void AddAxeButton_Click( object sender , RoutedEventArgs e ) => Axes.Add(new Axe()) ;
		void SaveAspectsButton_Click( object sender , RoutedEventArgs e ) => Setup.AspectsPath.Set(p=>Aspects.Each(a=>p.Pathin(a.Spec).WriteAll((string)a))) ;
		#endregion

		Aspect AspectSelection => AspectsGrid.SelectedItems.Count>1 ? new Aspect(AspectsGrid.SelectedItems.OfType<Aspect>()) : AspectsGrid.SelectedItem as Aspect ;
		void DisplayTable_SelectionChanged( object sender , SelectionChangedEventArgs e )
		{
			switch( (e.AddedItems.Count>0?e.AddedItems[0]as TabItem:null)?.Header as string )
			{
				case "Aspect" : ViewType = "Aspect" ; Aspect = AspectSelection ; break ;
				case "Spectrum" : ViewType = "Spectrum" ; Aspect = (((SpectrumTabs.SelectedItem as TabItem)?.Content as DataGrid)?.ItemsSource as Pathable??SpectrumTabs.ItemsSource.OfType<Pathable>().One())?.Spectrum ; break ;
				case "Quantile" : ViewType = "Quantile" ; Quantiles = Aspect ; break ;
				case "Graph" : ViewPanel = GraphPanel ; break ;
				case "Map" : ViewPanel = MapPanel ; break ;
			}
		}
		void DataGridDeleteCommandBinding_Executed( object sender , ExecutedRoutedEventArgs _=null ) => ((sender as DataGrid)?.ItemsSource as IList).Set(l=>(sender as DataGrid)?.SelectedItems.OfType<object>().ToArray().Each(l.Remove)) ;
		void SourcesGridDeleteCommandBinding_Executed( object sender , ExecutedRoutedEventArgs _=null ) => (sources as IList).Set(l=>(sender as DataGrid)?.SelectedItems.OfType<Aspect>().ToArray().Each(a=>{l.Remove(a);Presources.Remove(a.Raw);})) ;

		#region Graphing
		void Graph_Draw( object sender , RoutedEventArgs e = null ) { ViewPanel = GraphPanel ; GraphPanel.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : GraphDrawAspect() ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		void Map_Draw( object sender , RoutedEventArgs e = null ) { ViewPanel = MapPanel ; MapPanel.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : MapDrawAspect() ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		#region State
		string ViewType ; Canvas ViewPanel ; Dictionary<string,Quantilable> QuantileData = new Dictionary<string,Quantilable>() ;
		(double Width,double Height) MainFrameSize => (MainFrame.ColumnDefinitions[1].ActualWidth-ViewScreenBorder.Width,MainFrame.RowDefinitions[1].ActualHeight-ViewScreenBorder.Height) ;
		IEnumerable<Aspect> DrawingSources => Sources.Except(SourcesGrid.SelectedItems.OfType<Aspect>()) ;
		IEnumerable<Aspect> DrawingResources { get => Resources ; set { if( DrawingSourcesUpdate = value!=null ); else DrawingValue = null ; } }
		IEnumerable<Axe> DrawingAxes => AspectAxisGrid.SelectedItems.OfType<Axe>().Select(a=>a.DeRef).ToArray() ;
		List<(string Aspect,List<(string Spec,double?[] Val)> Axes)> DrawingValue { get => draval.Set(_=>UpdateDrawingAxes()).Set(_=>UpdateDrawingSources()).Get(_=>draval) ; set { draval = value ; DrawingRange = null ; } } List<(string Aspect,List<(string Spec,double?[] Val)> Axes)> draval ;
		Dictionary<string,(double Min,double Max)> DrawingRange ; (IList Added,IList Removed) DrawingAxesUpdate ; bool DrawingSourcesUpdate ;
		void UpdateDrawingAxes()
		{
			var (added,removed) = DrawingAxesUpdate ; 
			//if( removed?.Count>0 ) foreach( var asp in draval ) foreach( var axe in removed ) asp.Axes.IndexWhere(a=>a.Spec==axe.Spec).nil(i=>i<0).Use(asp.Axes.RemoveAt) ; // removing is not applied to optimize reuse of axe
			if( added?.Count>0 ) foreach( var asp in draval ) { var asv = DrawingResources.One(a=>a.Spec==asp.Aspect) ; foreach( Axe axe in added ) if( asp.Axes.Any(a=>a.Spec==axe.Spec) ); else asp.Axes.Add((axe.Spec,asv[axe.Spec].ToArray())) ; }
			DrawingAxesUpdate = (null,null) ; if( added?.Count+removed?.Count>0 ) DrawingRange = null ;
		}
		void UpdateDrawingSources()
		{
			if( DrawingSourcesUpdate && DrawingResources is IEnumerable<Aspect> sources ) if( draval.Count<=0 || sources.Any(s=>!s.Regular) ) DrawingValue = null ; else
			{
				sources.Except(s=>s.Spec,draval.Select(s=>s.Aspect)).ToArray().Each(source=>draval.Add((source.Spec,source.Intersect(a=>a.Spec,draval[0].Axes.Select(x=>x.Spec)).Select(a=>(a.Spec,a.ToArray())).ToList()))) ;
				draval.Except(s=>s.Aspect,sources.Select(s=>s.Spec)).ToArray().Each(a=>draval.Remove(a)) ; DrawingRange = null ;
			}
			DrawingSourcesUpdate = false ;
		}
		#endregion
		async void GraphDrawAspect()
		{
			var axes = DrawingAxes ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 ||!( AspectAxisGrid.SelectedItem is Axe xaxe ) ) return ;
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var val = DrawingValue ; if( val==null ) await Task.Factory.StartNew(()=> val = DrawingValue = DrawingResources.Select(asp=>(asp.Spec,asp.Where(a=>a.Spec==xaxe.Spec||yaxes.Contains(a.Spec)).Select(a=>(a.Spec,a.ToArray())).ToList())).ToList() ) ;
			var rng = DrawingRange ; if( rng==null )
			{
				DrawingRange = rng = new Dictionary<string,(double Min,double Max)>() ;
				foreach( var vax in val.SelectMany(s=>s.Axes) ) if( vax.Val.Where(v=>v!=null).Cast<double>().ToArray() is double[] a && a.Length>0 )
					rng[vax.Spec] = rng.ContainsKey(vax.Spec) ? rng[vax.Spec] = (Math.Min(rng[vax.Spec].Min,a.Min()),Math.Max(rng[vax.Spec].Max,a.Max())) : (a.Min(),a.Max()) ;
			}
			if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v ) => axe.Binder.No() ? Format(v) : axb.Of(v) ;
				for( var m=0 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20);}) ) ;
				for( var m=50 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes) )
				{
					var y = rng[ax] ; axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=height-50 ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			foreach( var asp in DrawingSources )
			{
				var asv = val.One(a=>a.Aspect==asp.Spec) ; var xax = asv.Axes.One(a=>a.Spec==xaxe.Spec) ; var color = new SolidColorBrush(Coloring(asp)) ; foreach( var ax in asv.Axes ) if( yaxes.Contains(ax.Spec) ) try
				{
					var ptss = new List<(int Count,int From)>() ;
					{
						int c,i,ac ; for( i=0 , c=0 , ac=ax.Val.Length ; i<ac ; ++i ) try { var stop = false ; if( xax.Val.At(i)!=null&&ax.Val.At(i)!=null ) ++c ; else stop = true ; if( stop||asp.Raw?[i]?.Mark==Mark.Stop ) { if( c>0 ) ptss.Add((c,i-c+(stop?0:1))) ; c = 0 ; } }
						catch( System.Exception e ) { Trace.TraceWarning($"Points calculation problem at {i}/{c}/{ac} : {e}") ; }
						if( c>0 ) ptss.Add((c,i-c)) ;
					}
					foreach( var pts in ptss ) GraphPanel.Children.Add( new Polyline{
						Stroke = color , StrokeDashArray = Array.IndexOf(yaxes,ax.Spec).Get(j=>j<1?null:new DoubleCollection{j}) ,
						Points = new PointCollection(pts.Count.Steps(pts.From).Select(i=>ScreenPoint(((xax.Val[i].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0)+asp.Offset,height-(ax.Val[i].Value-rng[ax.Spec].Min)/(rng[ax.Spec].Max-rng[ax.Spec].Min).nil()*height??0)))
					} ) ;
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			Hypercube.Each(e=>Coordinates+=co[e.Key].One().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
		}
		async void MapDrawAspect()
		{
			var axes = DrawingAxes ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 || !( AspectAxisGrid.SelectedItem is Axe xaxe ) ) return ;
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var val = DrawingValue ; if( val==null ) await Task.Factory.StartNew(()=> val = DrawingValue = DrawingResources.Select(asp=>(asp.Spec,asp.Where(a=>a.Spec==xaxe.Spec||yaxes.Contains(a.Spec)).Select(a=>(a.Spec,a.ToArray())).ToList())).ToList() ) ;
			var rng = DrawingRange ; if( rng==null )
			{
				DrawingRange = rng = new Dictionary<string,(double Min,double Max)>() ;
				foreach( var vax in val.SelectMany(s=>s.Axes) ) if( vax.Val.Where(v=>v!=null).Cast<double>().ToArray() is double[] a && a.Length>0 )
					rng[vax.Spec] = rng.ContainsKey(vax.Spec) ? rng[vax.Spec] = (Math.Min(rng[vax.Spec].Min,a.Min()),Math.Max(rng[vax.Spec].Max,a.Max())) : (a.Min(),a.Max()) ;
			}
			if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v , int p ) => axe.Binder.No() ? Format(v,p) : axb.Of(v) ;
				for( var m=0 ; m<=width ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20);}) ) ;
				for( var m=50 ; m<=width ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; MapPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes.Take(1)) )
				{
					var y = rng[ax] ;  axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=height-50 ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			(double X,double Y) sha = ((Coordinates.FirstOrDefault(c=>c.Axe==xaxe.Spec)?.Info??State.Coordination(xaxe.Spec)).Evaluate()??0,(Coordinates.FirstOrDefault(c=>c.Axe==yaxes[0])?.Info??State.Coordination(yaxes[0])).Evaluate()??0) ;
			double zis = Math.Pow(Math.Sqrt(width*height),1D/3D) ; var shift = 0 ; var zi = Setup.PrimaryShape ;
			foreach( var asp in DrawingSources )
			{
				var asv = val.One(a=>a.Aspect==asp.Spec) ; var xax = asv.Axes.One(a=>a.Spec==xaxe.Spec) ; var yax = asv.Axes.One(a=>a.Spec==yaxes[0]) ;
				var pts =new List<(System.Windows.Point A,System.Windows.Point B,bool S,double? X,double? Y,(string Spec,double? Val)[] Z)>() ; var zaxes = yaxes.Skip(1).Select(z=>asv.Axes.One(a=>a.Spec==z)).ToArray() ;
				for( int i=0 , c = asp.Points.Count-1 ; i<c ; ++i ) if( xax.Val[i]!=null && yax.Val[i]!=null && xax.Val[i+1]!=null && yax.Val[i+1]!=null && !asp.Raw[i].Mark.HasFlag(Mark.Stop) ) try
				{
					var spt0 = ScreenPoint((xax.Val[i].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0,height-(yax.Val[i].Value-rng[yax.Spec].Min)/(rng[yax.Spec].Max-rng[yax.Spec].Min).nil()*height??0) ;
					var spt1 = ScreenPoint((xax.Val[i+1].Value-rng[xax.Spec].Min)/(rng[xax.Spec].Max-rng[xax.Spec].Min).nil()*width??0,height-(yax.Val[i+1].Value-rng[yax.Spec].Min)/(rng[yax.Spec].Max-rng[yax.Spec].Min).nil()*height??0) ;
					if( spt0.X>=0 && spt0.Y>=0 && spt1.X<=width && spt1.Y<=height ) pts.Add((spt0,spt1,asp.Raw[i+1].Mark.HasFlag(Mark.Stop),xax.Val[i],yax.Val[i],zaxes.Select(z=>(z.Spec,z.Val[i])).ToArray())) ;
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				for( var i=1 ; i<yaxes.Length ; ++i ) rng[yaxes[i]]=(pts.Min(p=>p.Z[i-1].Val).Value,pts.Max(p=>p.Z[i-1].Val).Value) ;
				var color = Coloring(asp) ; (double dx,double dy) lv = (0,0) ;
				foreach( var (A,B,S,X,Y,Z) in pts ) try
				{
					var za = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)).ToArray() ; var zb = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)?.Info??State.Coordination(z.Spec)).ToArray() ;
					var zicol = Z.At((zi+1)%2).nil(z=>z.Spec==null) ; var ziaro = Z.At(zi%2).nil(z=>z.Spec==null) ;
					var axcol = zicol.Get(z=>(z.Val-(zb.At((zi+1)%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At((zi+1)%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					var axaro = ziaro.Get(z=>(z.Val-(zb.At(zi%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At(zi%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					if( axcol<zb.At((zi+1)%2)?.Count-za.At((zi+1)%2)?.Size || axaro<zb.At(zi%2)?.Count-za.At(zi%2)?.Size ) continue ;
					var zisc = axcol==null && zicol?.Spec is string sp ? rng[sp].Min : zis ;
					var axarow = ziaro.use(z=>(axaro*zisc%zisc).Signate(zb.At(zi%2)?.Reverse==false?zisc:null as double?)??rng[z.Spec].Min) ;
					double x1 = A.X+shift*sha.X , y1 = A.Y+shift*sha.Y , x2 = B.X+shift*sha.X , y2 = B.Y+shift*sha.Y , ln = Math.Sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)) ; if( ln>0 ) lv = ((x2-x1)/ln,(y2-y1)/ln) ;
					MapPanel.Children.Add( new Line{ X1 =  x1, Y1 = y1 , X2 = x2 , Y2 = y2 ,
						Stroke = axcol.Get(z=>new SolidColorBrush(color*(float)(z%1).Signate(zb.At((zi+1)%2)?.Reverse==false?1:null as double?))) ?? new SolidColorBrush(color) ,
						StrokeThickness = axarow ?? ( axcol==null && (zicol?.Spec??ziaro?.Spec) is string spec ? rng[spec].Min : 1 ) ,
					} ) ;
					if( S ) MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-lv.dy*zis , Y2 = y2+lv.dx*zis , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // stop mark
					if( axcol>zb.At((zi+1)%2)?.Count || axaro>zb.At(zi%2)?.Count )
					{
						foreach( var v in Z ) Coordinates.FirstOrDefault(c=>c.Axe==v.Spec).Set(c=>c.Value=v.Val) ;
						Coordinates.FirstOrDefault(c=>c.Axe==xax.Spec).Set(c=>c.Value=X) ; Coordinates.FirstOrDefault(c=>c.Axe==yax.Spec).Set(c=>c.Value=Y) ;
						break ;
					}
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				++shift ;
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			Hypercube.Each(e=>Coordinates+=co[e.Key].One().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
		}
		async void GraphDrawQuantile()
		{
			(var width,var height) = ViewFrame = MainFrameSize ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=127,G=127,B=127}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=width ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=width ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = height , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=height ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = width , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var axes = DrawingAxes ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; var selas = DrawingSources.ToArray() ; var relas = DrawingResources.ToArray() ; var rng = new List<KeyValuePair<string,(double Min,double Max)>>() ; var k = 0 ;
			foreach( var axe in Quantiles ) if( axe.Spec!=null && QuantileData.At(axe.Spec) is Quantilable ax && await ax.Count()>0 && yaxes.Contains(axe.Spec) )
			{
				var axa = ax.Ax ; Filter.Entry.Binding axb = axa.Binder ; string format( double v ) => (axa?.Binder).No() ? Format(v) : axb.Of(v) ;
				var val = ax.SelectMany(v=>v.Skip(1)) ; ((double Min,double Max) x,(double Min,double Max) y) = ((ax.Min(a=>a[0]),ax.Max(a=>a[0])),(val.Min(),val.Max())) ;
				rng.Add(new KeyValuePair<string,(double Min,double Max)>(ax.Ax.Spec,x)) ; rng.Add(new KeyValuePair<string,(double Min,double Max)>($"Q({ax.Ax.Spec}){ax.Axon?.Spec}",y)) ;
				{
					for( var m=0 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,height-20-10*k);}) ) ;
					for( var m=50 ; m<=width ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenX(x.Min+m*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,-10+10*k);}) ) ;
					axa = ax.Axon ; axb = ax.Axon?.Binder ; for( var m=height-50 ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(ScreenY(y.Min+(height-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-20);Canvas.SetLeft(l,-4);}) ) ;
					if( x.Min<0 && x.Max>0 ) { var xZero = ScreenX(-x.Min/(x.Max-x.Min)*width) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = height , Stroke = Brushes.Gray } ) ; }
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenY(y.Max/(y.Max-y.Min)*height) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = width , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
				for( int j = 1 , cnt = ax.One()?.Length??0 ; j<cnt ; ++j ) if( selas.Contains(relas[j-1]) ) GraphPanel.Children.Add( new Polyline{
					Stroke = new SolidColorBrush( Coloring(relas[j-1]/* is Aspect asp?SourceIndex(asp):j-1)*/) ) , StrokeDashArray = k==0?null:new DoubleCollection{k} ,
					Points = new PointCollection(ax.Select(a=>ScreenPoint((a[0]-x.Min)/(x.Max-x.Min)*width,height-(a[j]-y.Min)/(y.Max-y.Min)*height)))
				} ) ;
				++k ;
			}
			Hypercube = rng ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			rng.Each(e=>Coordinates+=co[e.Key].One().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder}) ;
		}
		#endregion

		static int DecDigits( double value , int prec = 3 ) => value==0 ? 0 : (int)Math.Max(0,prec-Math.Log10(Math.Abs(value))) ;
		static string Format( double value , int prec = 3 ) => value.ToString("#."+new string('#',DecDigits(value,prec))) ;
		IEnumerable<KeyValuePair<string,(double Min,double Max)>> Hypercube ; (double Width,double Height) ViewFrame ; (Line X,Line Y) MouseCross , ScreenCross ;
		(double Width,double Height) ViewScreenBorder => (DisplayTable.Margin.Left+DisplayTable.Margin.Right+4,30) ;
		static readonly Color[] Colos = new[]{ new Color{A=255,R=255,G=0,B=0} , new Color{A=255,R=0,G=255,B=0} , new Color{A=255,R=0,G=0,B=255} , new Color{A=255,R=191,G=191,B=0} , new Color{A=255,R=0,G=191,B=191} , new Color{A=255,R=191,G=0,B=191} , new Color{A=255,R=223,G=159,B=0} , new Color{A=255,R=159,G=223,B=0} , new Color{A=255,R=0,G=223,B=159} , new Color{A=255,R=0,G=159,B=223} , new Color{A=255,R=159,G=0,B=223} , new Color{A=255,R=223,G=0,B=159} } ;
		static readonly FontStretch[] Fostres = new[]{ FontStretches.UltraExpanded , FontStretches.ExtraExpanded , FontStretches.Expanded , FontStretches.SemiExpanded , FontStretches.Normal , FontStretches.SemiCondensed , FontStretches.Condensed , FontStretches.ExtraCondensed , FontStretches.UltraCondensed } ;
		static readonly FontWeight[] Foweis = new[]{ /*FontWeights.ExtraBlack , FontWeights.Black ,*/ FontWeights.ExtraBold , FontWeights.Bold , FontWeights.SemiBold , FontWeights.Medium , FontWeights.Normal , FontWeights.Light , FontWeights.ExtraLight , FontWeights.Thin } ;
		Color Coloring( int index ) => index<0 ? Colors.Black : Colos[index%Colos.Length] ;
		void AspectAxisGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { var success = RefontAxes(sender) ; DrawingAxesUpdate = (e.AddedItems,e.RemovedItems) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; /*while( !success ) { await Task.Delay(100) ; success = RefontAxes(sender) ; }*/ }
		bool RefontAxes( object sender )
		{
			var success = true ; if( sender is DataGrid grid ); else return success ; var gen = grid.ItemContainerGenerator ; var sel = grid.SelectedItem ; int ix = 0 ; var sels = grid.SelectedItems.OfType<Axe>().ToArray() ;
			foreach( var item in sels ) if( gen.ContainerFromItem(item) is DataGridRow row ) if( row.Cell(0) is DataGridCell cell )
			{
				cell.FontStyle = sel==item?FontStyles.Normal:FontStyles.Italic ; cell.FontStretch = item==sel?FontStretches.Normal:Fostres[ix%Fostres.Length] ; cell.FontWeight = item==sel?FontWeights.Bold:Foweis[ix%Foweis.Length] ; if( item!=sel ) ++ix ;
			}
			else success = false ;
			foreach( var item in grid.Items.OfType<Axe>().Except(sels) ) if( gen.ContainerFromItem(item) is DataGridRow row )
				if( row.Cell(0) is DataGridCell cell && row.Cell(1) is DataGridCell coll ) { cell.FontStyle = coll.FontStyle ; cell.FontStretch = coll.FontStretch ; cell.FontWeight = coll.FontWeight ; } else success = false ;
			return success ;
		}

		#region Coordinates
		void Main_MouseMove( object sender , MouseEventArgs e ) => MousePoint = Mouse.GetPosition(ViewPanel) ;
		public class Coordinate : INotifyPropertyChanged
		{
			Main Context ;
			public event PropertyChangedEventHandler PropertyChanged ;
			public Coordinate( Main context , string axe ) => Info = (_byte = (Context = context).State[Axe = axe]).ParseCoinfo() ;
			public string Axe { get; }
			public double? Value { get => value ; internal set { this.value = value ; PropertyChanged.On(this,"Value,View") ; } } double? value ;
			public string View => Binding.Of(value) ;
			public string Byte { get => _byte ; set { if( Byte==value ) return ; Context.State[Axe] = _byte = value ; Info = value.ParseCoinfo() ; PropertyChanged.On(this,"Byte") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; } } string _byte ;
			public (double? Byte,uint? Count,bool Reverse)? Info { get => info ?? Context.State.Coordination(Axe) ; set { if( info.Equals(value) ) return ; info = value ; Byte = value.StringCoinfo() ; } } (double? Byte,uint? Count,bool Reverse)? info ;
			public (double Min,double Max) Range ;
			public string Bond { set => Binding = value ; } Filter.Entry.Binding Binding ;
			public string At { get => at ; set { if( value==at ) return ; Size = (at=value).Parse<uint>() ; PropertyChanged.On(this,"At") ; } } string at ;
			public uint? Size { get =>size ; set { if( value==size ) return ; size = value ; PropertyChanged.On(this,"Size") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; At = value.Stringy() ; } } uint? size ;
		}
		public Aid.Collections.ObservableList<Coordinate> Coordinates { get; private set; } = new Aid.Collections.ObservableList<Coordinate>() ;
		public System.Windows.Point? MousePoint
		{
			get => mousePoint ; set
			{
				MouseCross.X.Set(ViewPanel.Children.Remove) ; MouseCross.Y.Set(ViewPanel.Children.Remove) ; if( value==null || value?.X<0 || value?.Y<0 || value?.X>ViewFrame.Width || value?.Y>ViewFrame.Height ) return ;
				var asp = Hypercube is Array ; PropertyChanged.On( this, "MousePoint", (mousePoint=value).Use(m=>Hypercube.Each(a=>CoordinateSet(m,a,asp))) ) ;
				ViewPanel.Children.Add( MouseCross.X = new Line{ Stroke=Brushes.Gray , X1=0 , X2=ViewFrame.Width , Y1=value.Value.Y , Y2=value.Value.Y } ) ;
				ViewPanel.Children.Add( MouseCross.Y = new Line{ Stroke=Brushes.Gray , Y1=0 , Y2=ViewFrame.Height , X1=value.Value.X , X2=value.Value.X } ) ;
			}
		}
		void CoordinateSet( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a , bool asp )
		{
			var co = Coordinates.First(c=>c.Axe==a.Key) ; co.Value = ( asp ? AspectAxisGrid.SelectedItem is Axe x && a.Key==x.Spec : !a.Key.StartsBy("Q(") ) ?
			ScreenX(AxeXByMouse(m,a),a.Value) : ViewPanel==GraphPanel || Coordinates.IndexOf(co)<2 ? ScreenY(AxeYByMouse(m,a),a.Value) : AxeZByMouse(a.Key) ;
		}
		double AxeXByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => m.X/ViewFrame.Width*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double AxeYByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => (ViewFrame.Height-m.Y)/ViewFrame.Height*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double? AxeZByMouse( string a )
		{
			var x = Coordinates[0]?.Value ; var y = Coordinates[1]?.Value ; var ax = Coordinates[0]?.Axe ; var ay = Coordinates[1]?.Axe ; Aspect.Point? op = null ; double? ov = null , cv = null ;
			foreach( var src in Sources ) foreach( var pt in src.Points ) if( (cv=(pt[ax]-x).Sqr()+(pt[ay]-y).Sqr())<ov || ov==null ) { op = pt ; ov = cv ; }
			return op?[a] ;
		}
		#endregion

		#region Focusing
		System.Windows.Point? mousePoint , screenPoint ; System.Windows.Rect? ScreenRect ;
		System.Windows.Point? ScreenOrigin
		{
			get => screenPoint ; set
			{
				ScreenCross.X.Set(ViewPanel.Children.Remove) ; ScreenCross.Y.Set(ViewPanel.Children.Remove) ; var p = ScreenMouse ; screenPoint = value.Get(v=>p) ; if( value==null ) return ;
				ViewPanel.Children.Add( ScreenCross.X = new Line{ Stroke=Brushes.Orange , X1=0 , X2=ViewFrame.Width , Y1=value.Value.Y , Y2=value.Value.Y } ) ;
				ViewPanel.Children.Add( ScreenCross.Y = new Line{ Stroke=Brushes.Orange , Y1=0 , Y2=ViewFrame.Height , X1=value.Value.X , X2=value.Value.X } ) ;
			}
		}
		System.Windows.Point? ScreenMouse { get { if( ScreenRect==null || MousePoint==null ) return MousePoint ; (var width,var height) = MainFrameSize ; var p = MousePoint.Value ; var r = ScreenRect.Value ; return new System.Windows.Point(p.X*r.Size.Width/width+r.Location.X,p.Y*r.Size.Height/height+r.Location.Y) ; } }
		void ViewPanel_MouseDown( object sender, MouseButtonEventArgs e ) => ScreenOrigin = MousePoint ;
		void DisplayTable_MouseUp( object sender, MouseButtonEventArgs e ) { if( ScreenMouse==ScreenOrigin ) return ; var scr = ScreenOrigin.Get(s=>ScreenMouse.use(p=>new Rect(s,p))) ; if( scr==ScreenRect ) return ; ScreenRect = scr ; if( GraphTab.IsSelected ) Graph_Draw(sender) ; if( MapTab.IsSelected ) Map_Draw(sender) ; }
		void DisplayTable_MouseDoubleClick( object sender, MouseButtonEventArgs e ) { ScreenOrigin = null ; ScreenRect = null ; if( GraphTab.IsSelected ) Graph_Draw(sender,e) ; else if( MapTab.IsSelected ) Map_Draw(sender,e) ; }
		System.Windows.Point ScreenPoint( double x , double y ) => new System.Windows.Point(ScreenX(x),ScreenY(y)) ;
		double ScreenX( double x ) { if( ScreenRect==null ) return x ; var r = ScreenRect.Value ; return (x-r.Location.X)*ViewFrame.Width/r.Size.Width ; }
		double ScreenY( double y ) { if( ScreenRect==null ) return y ; var r = ScreenRect.Value ; return (y-r.Location.Y)*ViewFrame.Height/r.Size.Height ; }
		double ScreenX( double x , (double Min,double Max) e ) { if( ScreenRect==null ) return x ; var r = ScreenRect.Value ; var q = (e.Max-e.Min)/ViewFrame.Width ; var fx = (x-e.Min)/q ; return e.Min+r.Location.X*q+fx*r.Width/ViewFrame.Width*q ; }
		double ScreenY( double y , (double Min,double Max) e ) { if( ScreenRect==null ) return y ; var r = ScreenRect.Value ; var q = (e.Max-e.Min)/ViewFrame.Height ; var fy = (e.Max-y)/q ; return e.Max-r.Location.Y*q-fy*r.Height/ViewFrame.Height*q ; }
		#endregion

		#region Stepping
		void Coordinates_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.001) ;
		void Coordinates_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.001) ;
		void Coordinates_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.01) ;
		void Coordinates_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.01) ;
		void Coordinates_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.1) ;
		void Coordinates_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.1) ;
		void Coordinates_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(.001) ;
		void Coordinates_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(null) ;
		void Coordinates_CountLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-1) ;
		void Coordinates_CountRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+1) ;
		void Coordinates_CountUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-10) ;
		void Coordinates_CountDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+10) ;
		void Coordinates_CountPageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-100) ;
		void Coordinates_CountPageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+100) ;
		void Coordinates_CountHome_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(0) ;
		void Coordinates_CountEnd_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(null) ;
		void Coordinates_AtLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(-1) ;
		void Coordinates_AtRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(+1) ;
		void Coordinates_AtUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(1) ;
		void Coordinates_AtDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(null) ;
		void CoordinatesMove( double step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(Math.Max(.001*(c.Range.Max-c.Range.Min),(i.Byte+step*(c.Range.Max-c.Range.Min))??c.Range.Max-c.Range.Min),i.Count,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSet( double? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(state*(c.Range.Max-c.Range.Min),i.Count is uint m?state is double s?s==0?i.Count:Math.Min((uint)((c.Range.Max-c.Range.Min)/s),m):1U:null as uint?,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(i.Byte,i.Count.use(v=>(uint)Math.Min(i.Byte is double b?(c.Range.Max-c.Range.Min)/b:1,Math.Max(0,(int)v+step))),i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(i.Byte,state,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=c.Size.use(a=>(uint)Math.Max(0,(int)a+step))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=state) ; GridFocusHold(CoordinatesGrid,sel) ; }
		#endregion

		async void GridFocusHold( DataGrid grid , IEnumerable<object> sel ) { await Task.Delay(10) ; sel.Each(s=>grid.SelectedItems.Add(s)) ; grid.Focus() ; }

		#region Drifting
		void Source_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-1) ;
		void Source_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+1) ;
		void Source_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<5)) ;
		void Source_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<5)) ;
		void Source_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<10)) ;
		void Source_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<10)) ;
		void Source_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(0) ;
		void Source_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(MainFrameSize.Width) ;
		void SourceDriftMove( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset+=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		void SourceDriftSet( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		#endregion
		void DataGrid_Paste_CommandBinding_Executed( object sender, ExecutedRoutedEventArgs _=null )
		{
			if( sender==AspectAxisGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Axe{Spec=a.At(0),Resolvelet=a.At(1),Binder=a.At(2),Quantlet=a.At(3),Asrex=a.At(4).Parse(false),Aspectlet=a.At(5),Multi=a.At(6).Parse(false)}) ;
			if( sender==AspectTraitsGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Aspect.Traitlet{Spec=a.At(0),Lex=a.At(1),Bond=a.At(2)}) ;
			if( sender==AspectsGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Aspect{Spec=a.At(0),Taglet=a.At(1)}) ;
			if( sender==ActionFilterGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Filter.Entry{Filter=a.At(0),Traits=a.At(1),Matrix=a.At(2),Associer=a.At(3),Matter=a.At(4),Query=a.At(5)}) ;
			if( sender==SourceFilterGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Filter.Entry{Rex=a.At(0).Parse(false),Filter=a.At(1),Query=a.At(2)}) ;
			if( sender==AspectFilterGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Filter.Entry{Rex=a.At(0).Parse(false),Filter=a.At(1)}) ;
		}
		void DataGrid_Paste_CommandBinding_Executed( object sender , Func<string[],object> item )
		{
			if( sender as DataGrid is DataGrid grid && grid.ItemsSource is IList items ); else return ; var seli = grid.SelectedIndex.nil(i=>i<0)??items.Count ;
			foreach( var line in Clipboard.GetText().SeparateTrim(Environment.NewLine,voids:false) ) if( line.Separate('\t') is string[] traits ) item?.Invoke(traits).Set(i=>items.Insert(seli,i)) ;
		}
		void DataGrid_Cut_CommandBinding_Executed( object sender, ExecutedRoutedEventArgs _=null ) { if( sender is DataGrid grid ); else return ; ApplicationCommands.Copy.Execute(null,grid) ; ApplicationCommands.Delete.Execute(null,grid) ; }
	}
	class Presources : IEnumerable<Pathable>
	{
		IList Origin ; List<Pathable> Basis ; DataGrid Grid ; Main Main ;
		public Presources( DataGrid grid , Main main ) { Origin = ( Grid = grid ).SelectedItems ; Main = main ; grid.SelectionChanged += Grid_SelectionChanged ; }
		void Grid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( Main.BlockSourcesUpdate ) return ; e.RemovedItems.OfType<Pathable>().Each(p=>Basis?.Remove(p)) ; e.AddedItems.OfType<Pathable>().Each(p=>Basis?.Remove(p)) ; }
		IEnumerable<Pathable> Original => Origin.OfType<Pathable>() ;
		public IEnumerator<Pathable> GetEnumerator() => ( Basis is List<Pathable> b ? b.Union(Original) : Original ).GetEnumerator() ; IEnumerator IEnumerable.GetEnumerator() => GetEnumerator() ;
		public int IndexOf( Pathable path ) => Basis?.IndexOf(path) is int i && i>=0 ? i : Origin.IndexOf(path) is int j && j>=0 ? j+(Basis?.Count??0) : -1 ;
		public void Snapshot() => Basis = ( Basis is List<Pathable> b ? b.Union(Original):Original ).ToList() ;
		public void Clean() => Basis = null ;
		public void Remove( Pathable path ) { Basis?.Remove(path) ; if( Origin.Contains(path) ) Origin.Remove(path) ; else Main.Grid_Coloring(Grid) ; }
		public void Reselect()
		{
			bool recolor = false ; if( Basis?.Intersect(Grid.Items.OfType<Pathable>()).ToArray() is IEnumerable<Pathable> join )
			{
				foreach( var path in join.Intersect(Original) ) Basis?.Remove(path) ;
				if( join.Except(Original).ToArray() is Pathable[] exce && exce.Length>0 ) foreach( var path in exce ) Origin.Add(path) ;
				else recolor = true ;
			}
			if( recolor ) Main.Grid_Coloring(Grid) ;
		}
	}
	static class MainExtension
	{
		public static IEnumerable<Objective> Issue<Objective>( this IEnumerable<Objective> items , params (Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)[] refine ) => items==null ? null : refine?.Length>0 ? refine?.Length>1 ? refine.SelectMany(items.Issue).Distinct() : items.Issue(refine[0]) : items ;
		public static IEnumerable<Objective> Issue<Objective>( this IEnumerable<Objective> items , (Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query) refine ) => items==null ? null : refine.Query==null ? refine.Filter==null ? items : items.Where(refine.Filter) : refine.Filter==null ? refine.Query(items) : refine.Query(items.Where(refine.Filter)) ;
		public static IEnumerable<Aspect> Reprojection( this IList<Aspect> sources ) => sources.Each((s,a,i)=>a.Sources=s.Skip(i).Concat(s.Take(i)).ToArray()) ;
	}
}
