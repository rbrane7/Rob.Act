using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.ComponentModel;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Diagnostics;
using Microsoft.Win32;
using Aid.Extension;
using System.Collections.Specialized;
using System.Globalization;
using Aid.IO;
using Aid.Extension.Private;

namespace Rob.Act.Analyze
{
	using Book = Gen.Book ;
	using System.Text.RegularExpressions ;
	/// <summary>
	/// Interaction logic for MainWindow.xaml
	/// </summary>
	public partial class Main : Window , INotifyPropertyChanged
	{
		public static Settings Setup => setup?.Result ; static readonly Aid.Prog.Setup<Settings> setup ;
		static string External( Uri uri ) => Setup?.External.One(i=>i.crit.Of(uri,true)).app ;//?? ( uri.Scheme switch { string s when s==Uri.UriSchemeHttp||s==Uri.UriSchemeHttps => @"C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe" , _ => null } ) ;
		static Main()
		{
			AppDomain.CurrentDomain.Load(typeof(Translation).Assembly.FullName) ;
			new Aid.Prog.Setup.App("Init.log") ; setup = (Resetup,e=>Trace.TraceError($"Setup Settings {e}")) ;
			Doct = (Setup.Doctee.Uri(),e=>Trace.TraceError($"Doctor {e}")) ; Trace.TraceInformation($"{Aid.Prog.Setup.Basis} with {Aid.The.Run.Basis}") ;
		}
		static Aid.Prog.Doct Doct ;
		public static readonly Aspect Laboratory = new() ;
		readonly Presources Presources ;
		static void Resetup( Settings past )
		{
			if( Doct?["Main"] is not Main main ) return ;
			if( Setup?.ActionTraits?.Equates(past?.ActionTraits)==false ) main.Dispatcher.Invoke(()=>main.BookGrid_AutoGeneratedColumns(main.BookGrid)) ;
			if( Setup?.SpectrumBinds?.Equates(past?.SpectrumBinds)==false ) main.Book.Each(p=>p.Spectrum.Reform(Setup.SpectrumBinds)) ;
			if( Setup?.SubjectMass.Equates(past?.SubjectMass)==false ) Basis.Mass = Setup.SubjectMass ;
			if( Setup?.Aggregates.Equates(past?.Aggregates)==false )
			{
				foreach( var ag in past.Aggregates.Except(Setup.Aggregates,a=>a.Code) ) main.Aggregation.RemoveWhere(a=>a.Code==ag.Code) ;
				foreach( var ag in Setup.Aggregates.Except(past.Aggregates,a=>a.Code) ) main.Aggregation.Add((ag.Tags.Select(t=>new Regex(t)).ToList(),ag.Code.Compile<Func<IEnumerable<(object,Pathable)>,object>>(),ag.Code)) ;
				foreach( var ag in Setup.Aggregates.Join(past.Aggregates,o=>o.Code,i=>i.Code,(o,i)=>(In:o.Tags,Out:i.Tags,o.Code)) )
					if( main.Aggregation.at(a=>a.Code==ag.Code).Value is var agr && agr.Tags is IList<Regex> tags ) { tags.Clear() ; ag.In.Each(c=>tags.Add(c.Get(e=>new Regex(e)))) ; }
			}
		}
		public State State { get => state ; private set => state = (value??new()).Set(s=>s.Context=this) ; } State state ;
		//FileSystemWatcher[] WorkoutsWatchers ;
		public event PropertyChangedEventHandler PropertyChanged ;
		void PropertyChangedOn<Value>( string properties , Value value ) => Dispatcher.Invoke(()=>{ PropertyChanged.On(this,properties,value) ; if( properties.Consists("Sources") ) Redraw() ; }) ;
		public Main()
		{
			InitializeComponent() ; Presources = new Presources(BookGrid,this) ; AppDomain.CurrentDomain.Load(typeof(AxeOperations).Assembly.FullName) ; ViewPanel = GraphPanel ; DataContext = this ;
			Doct += (this,"Main") ; Aspectables.The = (()=>Book.Entries.Select(p=>p.Spectrum).Union(Aspects.Entries),()=>Aspects.Entries) ; SourcesGrid.ItemContainerGenerator.ItemsChanged += SourcesGrid_ItemsChanged ; Task.Factory.StartNew(Load) ;
			Title = $"{Aid.The.Run.Appi} {System.Reflection.Assembly.GetEntryAssembly().GetName().Version} {Setup.Doctee} {setup.Config}" ;
			LevelKeyUp += async ()=>{ var resel = Reselection.ToArray() ; Reselection.Clear() ; await Task.Run(()=>Main_LevelKeyUp(resel)) ; } ;
		}
		void Main_LevelKeyUp( IEnumerable<KeyValuePair<object,List<SelectionChangedEventArgs>>> reselection )
		{
			foreach( var entry in reselection )
				if( entry.Key == BookGrid ) try { CumulativeUpdate = true ; BookGrid_SelectionChanged(entry.Key,entry.Value) ; } finally { CumulativeUpdate = false ; }
				else if( entry.Key == SourcesGrid ) try { CumulativeUpdate = true ; SourcesGrid_SelectionChanged(entry.Key,null) ; } finally { CumulativeUpdate = false ; }
				else if( entry.Key == AspectAxisGrid ) Dispatcher.Invoke(()=>{CumulativeUpdate=true;try{AspectAxisGrid_SelectionChanged(entry.Key,entry.Value.SelectionsItems());}finally{CumulativeUpdate=false;}}) ;
				else if( entry.Key == AspectsGrid ) Dispatcher.Invoke(()=>{CumulativeUpdate=true;try{AspectTabs_Selected(entry.Key,entry.Value.One());}finally{CumulativeUpdate=false;}}) ;
		}
		bool CumulativeUpdate ;
		void Load()
		{
			Setup.Altiplane.nil(a=>a.Grade==0).Use(g=>{
				Path.Altiplanes = new List<Path.Altiplane>() ;
				foreach( var a in System.IO.Directory.GetFiles(Setup.StatePath,$"{Altiplane.FileSign}*{Path.Altiplane.ExtSign}") ) { Trace.TraceInformation($"Loading {a}") ; Path.Altiplanes.Add(new Path.Altiplane(a){Radius=g.Radius}) ; }
				if( Path.Altiplanes.Count==0 ) Path.Altiplanes.Add(new Path.Altiplane(g.Grade,g.Grane){Radius=g.Radius}) ;
			}) ;
			Setup.WorkoutsPaths.SeparateTrim('|').SelectMany(l=>l.MatchingFiles(Setup?.WorkoutsSeed)).EachGuard(f=>NewAction(f,Setup?.WorkoutsFilter).Set(a=>Trace.TraceInformation($"{(Setup?.WorkoutsFilter?.Invoke(a)!=false?"Loaded":"Ignored")} {f}")),(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			Setup.AspectsPaths.SeparateTrim('|').SelectMany(l=>l.MatchingFiles()).EachGuard(f=>{Trace.TraceInformation($"Loading {f}");NewAspect(f,Setup?.AspectsFilter);},(f,e)=>Trace.TraceError($"{f} faulted by {e}")) ;
			/*WorkoutsWatchers =*/ Setup.WorkoutsPaths.SeparateTrim('|').Select(l=>new FileSystemWatcher(l){EnableRaisingEvents=true}.Set(w=>{ w.Edited += NewAction ; w.Deleted += (s,a)=>Book-=p=>p.Origin==a.FullPath ; })).Each() ;
			State = new State{ Context = this } ;
		}
		protected override void OnClosing( CancelEventArgs e ) { Doct?.Dispose() ; base.OnClosing(e) ; }
		protected override void OnClosed( EventArgs e ) { base.OnClosed(e) ; Process.GetCurrentProcess().Kill() ; }
		Path NewAction( string file , Predicate<Pathable> filter = null ) => file?.Reconcile().Internalize().Set(p=>p.Origin=file).Set(Translation.Partitionate).Set(p=>p.Spectrum.Reform(Setup.SpectrumBinds)).Set(p=>{Book|=filter?.Invoke(p)!=false?p:null;if(Book.Contains(p)){ActionEnhancing(p,ActiveRefiner);Dispatcher.Invoke(SaveBook);}}) ;
		void NewAction( object subject , System.IO.FileSystemEventArgs arg ) => NewAction(arg.FullPath.Null(f=>Setup?.WorkoutsSeed?.Invoke(new System.IO.FileInfo(f))==false),Setup?.WorkoutsFilter).Set(p=>Path.Medium?.Interact(p,true)) ;
		void NewAspect( string file , Predicate<Aspect> filter = null ) => ((Aspect)file.ReadAllText()).Set(a=>a.Origin=file).Set(a=>Aspects+=filter?.Invoke(a)!=false?a:null) ;
		public Book Book { get ; private set ; } = new("Main") ;
		public Filter ActionFilterFilter { get => actionFilterFilter ; internal set { if( value==actionFilterFilter ) return ; actionFilterFilter = value ; PropertyChanged.On(this,"ActionFilterFilter") ; } } Filter actionFilterFilter ;
		public Filter ActionFilter { get => actionFilter ; internal set { if( value==actionFilter ) return ; actionFilter = value ; PropertyChanged.On(this,"ActionFilter") ; } } Filter actionFilter ;
		public Filter SourceFilter { get => sourceFilter ; internal set { if( value==sourceFilter ) return ; sourceFilter = value ; PropertyChanged.On(this,"SourceFilter") ; } } Filter sourceFilter ;
		public Filter AspectFilter { get => aspectFilter ; internal set { if( value==aspectFilter ) return ; aspectFilter = value ; PropertyChanged.On(this,"AspectFilter") ; } } Filter aspectFilter ;
		string[] ActionTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Traits.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.ActionTraits ;
		string[] MatrixTraits => ActionFilterGrid.SelectedItems.OfType<Filter.Entry>().SelectMany(e=>e.Matrix.SeparateTrim(';',braces:null,voids:false)??Enumerable.Empty<string>()).Distinct().ToArray().Null(t=>t.Length<=0) ?? Setup.MatrixTraits?.Concat(BookGrid.SelectedItems.OfType<Path>().SelectMany(p=>p.Metax?.Bonds??Enumerable.Empty<string>()).Distinct()).ToArray() ;
		
		#region Reselections
		internal (bool Book,bool Sources,bool Aspect) BlockUpdate ; System.Collections.Concurrent.ConcurrentMap<object,List<SelectionChangedEventArgs>> Reselection = new() ;
		void ActionFilterFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { BlockUpdate.Book = true ; try { FilterGrid_SelectionChanged<Filter.Entry>(sender,f=>{ActionFilter.Refinement=f;}) ; } finally { BlockUpdate.Book = false ; } }
		async void BookGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( BlockUpdate.Sources ) return ; if( KeyLevel==default ) { await Task.Factory.StartNew(()=>Resources_Update(e.AddedItems,e.RemovedItems)) ; Grid_Coloring(sender) ; } else (Reselection[sender]??=new()).Add(e) ; }
		void BookGrid_SelectionChanged( object sender , IList<SelectionChangedEventArgs> e ) { var(add,rem) = e.SelectionsItems() ; Resources_Update(add,rem) ; Dispatcher.Invoke(()=>Grid_Coloring(sender)) ; }
		void ActionFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e )
		{
			if( BlockUpdate.Book ) return ; Presources.Snapshot() ; using( new Aid.Closure(()=>BlockUpdate.Sources=true,()=>BlockUpdate.Sources=false) )
			FilterGrid_SelectionChanged<Pathable,Associable>(sender,async a=>{Book.Refinement=a.Select(f=>(f.Filter,f.Query));BookGrid_AutoGeneratedColumns();Presources.Reselect();await Task.Factory.StartNew(()=>ActionsEnhancing(a));BookGrid_AutoGeneratedColumns();Presources.Reselect();}) ;
		}
		void SourceFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => FilterGrid_SelectionChanged<Aspect>(sender,f=>{Sourcer=f;Sources=sources;}) ;
		void AspectFilterGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { BlockUpdate.Aspect = true ; try { FilterGrid_SelectionChanged<Aspect>(sender,f=>Aspects.Refinement=f) ; } finally { BlockUpdate.Aspect = false ; } }
        static void FilterGrid_SelectionChanged<Objective>( object sender , Action<(Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>>)[]> doing ) => (sender as DataGrid)?.SelectedItems.OfType<Filter.Entry>().Select(f=>(f.ToFilter<Objective>(),f.ToQuery<Objective>())).ToArray().Set(doing) ;
		void FilterGrid_SelectionChanged<Objective,Enhancer>( object sender , Action<(Func<Objective,bool> Filter,Func<Enhancer,bool> Associer,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)[]> doing )
		{
			IEnumerable<Objective> context = null ; // context objectives of filtering
			var refiner = Refiner<Objective,Enhancer>(sender as DataGrid).Select(e=>(e.Filter.Get(ff=>{context??=BookGrid.SelectedItems.OfType<Objective>().ToArray();return new Func<Objective,bool>(p=>ff(p,context));}),e.Associer,e.Query)).ToArray() ;
			ActiveRefiner = refiner as (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] ;
			doing( refiner ) ;
		}
		void SourcesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( KeyLevel==default ) Sources = sources ; else (Reselection[sender]??=new()).Add(e) ; }
		void AspectAxisGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( KeyLevel!=default ) (Reselection[sender]??=new()).Add(e) ; else AspectAxisGrid_SelectionChanged(sender,(e.AddedItems,e.RemovedItems)) ; }
		void AspectAxisGrid_SelectionChanged( object sender , ( IList add , IList rem ) change ) { RefontAxes(sender) ; DrawingAxesUpdate = change ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; /*while( !success ) { await Task.Delay(100) ; success = RefontAxes(sender) ; }*/ }
		void AspectTraitsGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) => new HashSet<string>(AspectTraitsGrid.SelectedItems.OfType<Aspect.Traitlet>().Select(t=>t.Spec)).Set(t=>SourcesGrid.Columns.Skip(1).Each(c=>c.Visibility=t.Contains(c.Header)?Visibility.Hidden:Visibility.Visible)) ;
		void CoordinatesGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( MapTab.IsSelected ) Map_Draw(this) ; }
		#endregion

        static IEnumerable<(Func<Objective,IEnumerable<Objective>,bool> Filter,Func<Enhancer,bool> Associer,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)> Refiner<Objective,Enhancer>( DataGrid sender ) => sender.SelectedItems.OfType<Filter.Entry>().Select(f=>f.ToRefiner<Objective,Enhancer>(Setup?.VicinerNaming)) ;
		(Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] ActiveRefiner ; Metax ActiveMetax ;

		public Aid.Collections.ObservableList<Aspect>.Filtered Aspects { get ; private set ; } = new Aid.Collections.ObservableList<Aspect>.Filtered{Sensible=true} ;
		void ActionsEnhancing( params (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] refiner ) { ActiveMetax = null ; foreach( var path in Book.ToArray() ) ActionEnhancing(path,refiner) ; Dispatcher.Invoke(SaveBook) ; }
		void ActionEnhancing( Pathable path , params (Func<Pathable,bool> Filter,Func<Associable,bool> Associer,Func<IEnumerable<Pathable>,IEnumerable<Pathable>> Query)[] refiner )
		{
			if( refiner==null || path==null ) return ; path.Spectrum.Trait.Clean() ;
			foreach( var refine in refiner ) if( refine.Filter?.Invoke(path)!=false ) foreach( var asp in Aspects.Entries )
				if( (refine.Associer?.Invoke((path,asp))??(refine.Filter!=null?Setup.ActionAssocier?.Invoke(path,asp):false))==true )
					new Aspect(asp){Source=path.Spectrum}.Set(a=>{path.Spectrum.Trait.Add(a.Trait);path.Spectrum.Tager+=a.Tager;}) ;
			PathEnhancing(path as Path) ;
		}
		void PathEnhancing( Path path ) => path.Set(p=>p.Metax=ActiveMetax??=new Metax(p.Metax?.Base??p.Dimension))?.Populate() ;
		void SaveBook() { if( ActionFilterGrid.SelectedItems.Count==1 && (ActionFilterGrid.SelectedItem as Filter.Entry)?.Matter.Null(v=>v.Void()) is string matter && Book.Count>0 && Setup?.WorkoutsPath is string path ) try{Book.Save(path,matter);}catch(System.Exception e){Trace.TraceError("Save Book failed on {0}:{1} : {2}",path,matter,e);} }

		#region Core
		public Aid.Collections.ObservableList<Axe> Axes { get ; private set ; } = new Aid.Collections.ObservableList<Axe>() ;
		/// <summary> Aspect is never null , either Spectrum , or aspect ready for projection . If without selection then set to <see cref="Laboratory"/> . </summary>
		public Aspect Aspect { get => Respect ; protected set { if( (value??Laboratory)==Aspect ) return ; Aspect.Set(a=>{a.CollectionChanged-=OnAspectChanged;a.PropertyChanged-=OnAspectChanged;}) ; (Respect=value??Laboratory).Set(a=>{a.CollectionChanged+=OnAspectChanged;a.PropertyChanged+=OnAspectChanged;}) ; AspectAxisGrid.CanUserAddRows = AspectAxisGrid.CanUserDeleteRows = AspectTraitsGrid.CanUserAddRows = AspectTraitsGrid.CanUserDeleteRows = AspectsGrid.SelectedItems.Count<=1 ; Resources = null ; PropertyChangedOn("Aspect",value) ; } } Aspect Respect = Laboratory ;
		public IEnumerable<Axe> Quantiles { get => quantiles??Enumerable.Empty<Axe>() ; private set { if( !quantiles.SequenceEquate(value) ) PropertyChangedOn("Quantiles",quantiles=value?.ToArray()) ; } } Axe[] quantiles ;
		public IEnumerable<Aspect> Sources { get => Resources.Issue(Sourcer) ; set => PropertyChangedOn("Sources",value) ; } (Func<Aspect,bool> Filter,Func<IEnumerable<Aspect>,IEnumerable<Aspect>> Query)[] Sourcer ;
		public new IEnumerable<Aspect> Resources { get => sources ??= new Aid.Collections.ObservableList<Aspect>(ActionsProjection) ; set { PropertyChangedOn("Resources", DrawingResources = sources = value ) ; Sources = value ; } } IEnumerable<Aspect> sources ;
		Aspect Projection( Pathable path ) => new(Aspect){Source=path.Spectrum} ;
		IEnumerable<Aspect> Projection( IEnumerable<Pathable> p ) => p.Select(Projection).ToArray().Reprojection() ;
		IEnumerable<Aspect> ActionsProjection => Presources.Get( p => Aspect is Path.Aspect ? p.Select(s=>s.Spectrum) : Projection(p) ) ;
		Aspect Resource( Pathable path ) => Aspect is Path.Aspect ? path.Spectrum : Projection(path) ;
		int SourceIndex( object item ) => item is Aspect asp ? Resources.IndexIf(a=>a==asp) is int i ? i : Presources.IndexOf(asp?.Raw) : item is Pathable path ? Resources.IndexIf(a=>a.Raw==path) is int j ? j : Presources.IndexOf(path) : -1 ;
		Color Coloring( object item ) => Coloring(SourceIndex(item)) ;
		#endregion

		void OnAspectChanged( object subject , NotifyCollectionChangedEventArgs arg=null ) { var sub = ActiveTabs ; Revoke : var six = sub.SelectedIndex ; if( sub==AspectTabs || sub==QuantileTabs ) Resources = null ; sub.SelectedIndex = -1 ; sub.SelectedIndex = six ; if( sub==AspectTabs ) { sub = QuantileTabs ; goto Revoke ; } }
		void OnAspectChanged( object subject , PropertyChangedEventArgs arg ) => OnAspectChanged(subject) ;
		void Resources_Update( IList add , IList rem )
		{
			//if( Multiaspected ) { Sources = null ; return ; } // inoptimal solution
			if( sources is not IList<Aspect> sl || add is null && rem is null ) return ;
			if( rem is not null ) foreach( Pathable path in rem ) sl.IndexIf(a=>a.Raw==path).Use(sl.RemoveAt) ; if( add is not null ) foreach( Pathable path in add ) if( !sl.Any(a=>a.Raw==path) ) Resource(path).Set(sl.Add) ; // Individual aspect perspective update .
			if( !Aspect.Regular ) sl.Reprojection() ; // Update of multi-sources for each aspect .
			Resources = sources ;
		}
		async internal void Grid_Coloring( object sender ) { for( var success = RecolorGrid(sender)?0:10 ; success>0 ; success -= RecolorGrid(sender)?success:1 ) await Task.Delay(100) ; }
		bool RecolorGrid( object sender )
		{
			var success = true ; if( sender is not DataGrid bg ) return success ;
			var gen = bg.ItemContainerGenerator ; foreach( var item in bg.Items )
			{
				/*bg.ScrollIntoView(item) ;*//*Performance problem, not usable*/ if( gen.ContainerFromItem(item) is not DataGridRow row ) continue ;
				if( row.Cell(0) is DataGridCell cell && cell.Foreground is SolidColorBrush b && Coloring(item) is Color c && b.Color!=c ) cell.Foreground = new SolidColorBrush(c) ; else success = false ;
			}
			return success ;
		}
		TabControl ActiveTabs => Aspect is Path.Aspect ? SpectrumTabs : AspectTabs ;

		#region Regeneration
		void AspectGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; Focusation.Grid[ActiveTabs] = grid ; var pts = grid.ItemsSource as Aspect.Point.Iterable ; var asp = pts?.Context ; grid.Columns.Clear() ; DrawingValue = null ;
			uint i=0 ; foreach( var ax in asp ) { Filter.Entry.Binding b = ax.Binder ; grid.Columns.Add(new DataGridTextColumn{Header=b.Name.No()?ax.Spec:b.Name,Binding=new Binding(b.Converter==null||b.Name.No()&&b.Path.No()?$"[{i}]":b.Path){StringFormat=b.Form,Converter=b.Converter}}) ; ++i ; }
			if( pts.Context.Raw?.Any(p=>p.Tags!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ; if( pts.Context.Raw?.Any(p=>p.Marklet!=null)==true ) grid.Columns.Add(new DataGridTextColumn{Header="Mark",Binding=new Binding("Marklet")}) ;
		}
		void QuantileGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; var src = Sources ; grid.Columns.Clear() ; if( grid.ItemsSource is Quantilable axe )
			{
				QuantileData[axe.Ax.Spec] = axe ; Filter.Entry.Binding b = axe.Ax.Binder , cb = axe.Axon?.Binder ;
				grid.Columns.Add(new DataGridTextColumn{Header=b.Of(axe.Ax.Distribution.One()),Binding=new Binding("[0]"){StringFormat=b.Form,Converter=b.Converter}}) ;
				uint i=1 ; foreach( var asp in src ) grid.Columns.Add(new DataGridTextColumn{Header=asp.Spec,Binding=new Binding($"[{i++}]"){StringFormat=cb.Form,Converter=cb.Converter}}) ;
			}
		}
		void SourcesGrid_AutoGeneratedColumns( object sender , EventArgs e )
		{
			var grid = sender as DataGrid ; var asp = Aspect ; grid.Columns.Clear() ;
			grid.Columns.Add(new DataGridTextColumn{Header="Spec",Binding=new Binding("Spec")}) ; var f = new HashSet<string>(AspectTraitsGrid.SelectedItems.OfType<Aspect.Traitlet>().Select(t=>t.Spec)) ;
			int i=0 ; foreach( var tr in asp.Trait ) grid.Columns.Add(new DataGridTextColumn{Header=tr.Name,Binding=new Binding("Trait"){ConverterParameter=i++,Converter=TraitConversion.The},Visibility=f.Contains(tr.Spec)?Visibility.Hidden:Visibility.Visible}) ;
			if( asp.Taglet!=null ) grid.Columns.Add(new DataGridTextColumn{Header="Tags",Binding=new Binding("Tags")}) ;
		}
		void BookGrid_AutoGeneratedColumns( object sender=null , EventArgs e=null ) => ConGrid_AutoGeneratedColumns(sender??BookGrid,true,ActionTraits) ;
		void MatrixGrid_AutoGeneratedColumns( object sender , EventArgs e=null ) { ConGrid_AutoGeneratedColumns(sender,false,MatrixTraits) ; Focusation.Grid[MatrixTabs] = sender as DataGrid ; }
		void ConGrid_AutoGeneratedColumns( object sender , bool keep , params string[] traits )
		{
			if( traits!=null && sender is DataGrid grid ) grid.Columns.Clear() ; else return ; if( keep ) Actras.Clear() ;
			foreach( Filter.Entry.Binding tr in traits ) { grid.Columns.Add(new DataGridTextColumn{Header=tr.Name,Binding=new Binding(tr.Path){Converter=tr.Converter,StringFormat=tr.Form}}) ; Actras.Add(tr) ; }
		}
		#endregion

		void ActionsFilterGrid_MouseRightButtonUp( object sender , MouseButtonEventArgs e )
		{
			if( Keyboard.IsKeyDown(Key.LeftShift) ) foreach( var item in Setup.Internal ) if( Keyboard.IsKeyDown(item.key) ) foreach( var path in Book.Cast<Path>() ) item.act(path) ;
		}
		void BookGrid_MouseRightButtonUp( object sender , MouseButtonEventArgs e )
		{
			if( Keyboard.IsKeyDown(Key.LeftShift) ) foreach( var item in Setup.Internal ) if( Keyboard.IsKeyDown(item.key) ) foreach( var path in BookGrid.SelectedItems.Cast<Path>() ) item.act(path) ;
			if( Keyboard.IsKeyDown(Key.F2) ) (BookGrid.SelectedItem as Path)?.IncludeSpecToOrigin() ; else
			if( Keyboard.IsKeyDown(Key.Escape) ) (BookGrid.SelectedItem as Pathable)?.Origin.Start(External) ; else
			if( Keyboard.IsKeyDown(Key.LeftCtrl) ) (BookGrid.SelectedItem as Pathable)?.Detail.Link(0).Start(External) ; else
			if( Keyboard.IsKeyDown(Key.LeftShift) ) (BookGrid.SelectedItem as Pathable)?.Detail.Link(1).Start(External) ; else
			if( Keyboard.IsKeyDown(Key.LeftAlt) ) (BookGrid.SelectedItem as Pathable)?.Detail.Link(2).Start(External) ; else
			if( sender is DataGrid grid && Actras.Count>0 ) foreach( var col in grid.Columns ) if( Actras.at(col.DisplayIndex) is Filter.Entry.Binding tr )
			col.Header = col.Header is string name && tr.Name==name && Aggregation.Apt(tr.Name) is Func<IEnumerable<(object,Pathable)>,object> ag ? tr.View(ag(Book.Select(p=>(tr.On(p),p)))).Null() ?? tr.Name : tr.Name ;
		}
		readonly List<Filter.Entry.Binding> Actras = new() ;
		public readonly Aggregator Aggregation = new() ;
		public class Aggregator : List<(List<Regex> Tags,Func<IEnumerable<(object value,Pathable path)>,object> Join,string Code)>
		{
			public static Aggregator Basis = new()
			{
				( new(){new("Dist|∫[^♀]")} , v=>v.Sum(e=>e.value as double?) , "Sum" ) ,
				( new(){new( "Time|∫♀")} , v=>v.Aggregate(TimeSpan.Zero,(a,t)=>a+((t.value as TimeSpan?)??TimeSpan.Zero)) , "SumTime" ) ,
				( new(){new("Date")} , v=>(v.Max(e=>e.value as DateTime?)-v.Min(e=>e.value as DateTime?)).use(t=>DateTime.MinValue+t) , "CenterDate" ) ,
				( new(){null,new("Speed|♂|☼|♥")} , v=>v.Average(e=>e.value as double?) , "Average" ) ,
				( new(){new("Speed|♂|☼|♥")} , v=>v.Centre(e=>e.value as double?,e=>e.path.Time.TotalSeconds) , "CentreTimely" ) ,
				( new(){new("Action|Act")} , v=>v.Distinct(e=>e.value as string).Stringy('|').Null(s=>s.Length>10) , "ConcatPipely" ) ,
				( new(){new("Pace|♀")} , v=>v.Centre(e=>(e.value as TimeSpan?)?.TotalSeconds,e=>(e.path as Path).Dist??0).use(TimeSpan.FromSeconds) , "CentrePace" ) ,
			} ;
			IEnumerable<(List<Regex> Tags,Func<IEnumerable<(object,Pathable)>,object> Join,string Code)> Content => this==Basis ? this : this.Union(Basis) ;
			public Func<IEnumerable<(object value,Pathable path)>,object> Apt( string axe ) => Content.optimal(e=>e.Tags.IndexIf(t=>t?.IsMatch(axe)==true))?.one.Join ;
			public IList<Regex> this[ string code ] => Content.at(one=>one.Code==code)?.Tags ;
			public (List<Regex> Tags,Func<IEnumerable<(object,Pathable)>,object> Join,string Code)[] this[ Regex rex ] => Content.Where(one=>rex.IsMatch(one.Code)).ToArray() ;
		}
		async void SourcesGrid_ItemsChanged( object sender , System.Windows.Controls.Primitives.ItemsChangedEventArgs e )
		{
			var gen = sender as ItemContainerGenerator ; for( int i=0 , c=gen.Items.Count ; i<c ; ++i )
			try { var j=0 ; Retry: if( gen.ContainerFromIndex(i) is DataGridRow row ) row.Cell(0).Foreground = new SolidColorBrush(Coloring(gen.Items[i] as Aspect)) ; else { await Task.Delay(100) ; if( ++j<10 ) goto Retry ; } } catch {}
		}
		void AspectTabs_Selected( object sender , SelectionChangedEventArgs e )
		{
			if( sender is DataGrid ) { AspectSelection = null ; if( KeyLevel!=default ) { (Reselection[sender]??=new()).Add(e) ; return ; } }
			var asp = e.AddedItems.Count>0 ? e.AddedItems[0] : null ; switch( (DisplayTable.SelectedItem as TabItem)?.Header )
			{
				case "Aspect" : if( !BlockUpdate.Aspect ) Aspect = AspectSelection ; break ; case "Spectrum" : (asp as Pathable)?.Spectrum.Set(a=>Aspect=a) ; break ;
				case "Graph" : case "Map" : case "Quantile" : if( Aspect is Path.Aspect ) break ; else goto case "Aspect" ;
			}
		}

		#region Hidden
		void AddActionButton_Click( object sender , RoutedEventArgs e ) { var dlg = new OpenFileDialog{Multiselect=true} ; if( dlg.ShowDialog(this)==true ) dlg.FileNames.Each(f=>NewAction(f)) ; }
		void AddAspectAxeButton_Click( object sender , RoutedEventArgs e ) => Aspect.Add(new Axe{Aspect=Aspect as Path.Aspect}.Set(Axes.Add)) ;
		void AddAspectTraitButton_Click( object sender , RoutedEventArgs e ) => Aspect.Trait.Add(new Aspect.Traitlet()) ;
		void AddAspectButton_Click( object sender , RoutedEventArgs e ) => Aspects.Add(new Aspect()) ;
		void AddAxeButton_Click( object sender , RoutedEventArgs e ) => Axes.Add(new Axe()) ;
		void SaveAspectsButton_Click( object sender , RoutedEventArgs e ) => Setup.AspectsPath.Set(p=>Aspects.Each(a=>p.Pathin(a.Spec).WriteAll((string)a))) ;
		#endregion

		Aspect AspectSelection { get { if( Asel is not null ) return Asel ; if( AspectsGrid.SelectedItems.Count<2 && !CumulativeUpdate ) return Asel = AspectsGrid.SelectedItem as Aspect ; var nex = AspectsGrid.SelectedItems.OfType<Aspect>() ; return Asel = new Aspect(CumulativeUpdate?nex.prepend(Aspect):nex) ; } set => Asel = value ; } Aspect Asel ;
		void DisplayTable_SelectionChanged( object sender , SelectionChangedEventArgs e )
		{
			switch( (e.AddedItems.Count>0?e.AddedItems[0]as TabItem:null)?.Header as string )
			{
				case "Aspect" : ViewType = "Aspect" ; Aspect = AspectSelection ; break ;
				case "Spectrum" : ViewType = "Spectrum" ; Aspect = (((SpectrumTabs.SelectedItem as TabItem)?.Content as DataGrid)?.ItemsSource as Pathable??SpectrumTabs.ItemsSource.OfType<Pathable>().One())?.Spectrum ; break ;
				case "Quantile" : ViewType = "Quantile" ; Quantiles = Aspect ; break ;
				case "Graph" : ViewPanel = GraphPanel ; break ;
				case "Map" : ViewPanel = MapPanel ; break ;
			}
		}
		void Aspect_MouseRightButtonDown( object sender , MouseButtonEventArgs e ) { if( Aspect is Path.Aspect ) { ViewType = "Aspect" ; Aspect = AspectSelection ; } }
		void Spectrum_MouseRightButtonDown( object sender , MouseButtonEventArgs e )
		{
			if( Aspect is Path.Aspect ) return ; ViewType = "Spectrum" ; Aspect = (((SpectrumTabs.SelectedItem as TabItem)?.Content as DataGrid)?.ItemsSource as Pathable??SpectrumTabs.ItemsSource.OfType<Pathable>().One())?.Spectrum ; Redraw(true) ;
		}
		void DataGridDeleteCommandBinding_Executed( object sender , ExecutedRoutedEventArgs _=null ) => (sender as DataGrid).Set(g=>(g.ItemsSource as IList).Set(l=>g.SelectedItems.OfType<object>().ToArray().Each(l.Remove))) ;
		void SourcesGridDeleteCommandBinding_Executed( object sender , ExecutedRoutedEventArgs _=null ) => (sources as IList).Set(l=>(sender as DataGrid)?.SelectedItems.OfType<Aspect>().ToArray().Each(a=>{l.Remove(a);Presources.Remove(a.Raw);})) ;

		#region Graphing
		void Redraw( bool clean = false ) { if( clean ) DrawingValue = null ; if( GraphTab.IsSelected ) Graph_Draw(this) ; else if( MapTab.IsSelected ) Map_Draw(this) ; }
		void Graph_Draw( object sender = null , RoutedEventArgs e = null ) { if( (ViewPanel = GraphPanel)==null ) return ; GraphPanel.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : GraphDrawAspect(sender!=null) ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		void Map_Draw( object sender = null , RoutedEventArgs e = null ) { if( (ViewPanel = MapPanel)==null ) return ; MapPanel?.Children.Clear() ; switch( ViewType ) { case "Aspect" : case "Spectrum" : MapDrawAspect(sender!=null) ; return ; case "Quantile" : GraphDrawQuantile() ; return ; } }
		#region State
		string ViewType ; Canvas ViewPanel ; readonly Dictionary<string,Quantilable> QuantileData = new() ;
		(double Width,double Height) MainFrameSize => (MainFrame.ColumnDefinitions[1].ActualWidth-ViewScreenBorder.Width,MainFrame.RowDefinitions[1].ActualHeight-ViewScreenBorder.Height) ;
		((double Width,double Height) Size,(double Width,double Height) Origin) ViewFrame => (MainFrameSize.Margin(ViewOrigin),ViewOrigin) ;
		public static double ViewScreenMargin => Setup?.ViewScreenMargin ?? 0 ;
		IEnumerable<Aspect> DrawingSources => Sources.Except(SourcesGrid.SelectedItems.OfType<Aspect>()) ;
		IEnumerable<Aspect> DrawingResources { get => Resources ; set { if( DrawingSourcesUpdate = value!=null ); else DrawingValue = null ; } }
		IEnumerable<Axe> DrawingAxes => AspectAxisGrid.SelectedItems.OfType<Axe>().Select(a=>a.DeRef).ToArray() ;
		List<(string Aspect,List<(string Spec,double?[] Val,string Base,double Offset)> Axes)> DrawingValue { get => draval.Set(_=>UpdateDrawingAxes()).Set(_=>UpdateDrawingSources()).Get(_=>draval) ; set { draval = value ; DrawingRange = null ; } } List<(string Aspect,List<(string Spec,double?[] Val,string Base,double Offset)> Axes)> draval ;
		Dictionary<string,(double Min,double Max)> DrawingRange ; (IList Added,IList Removed) DrawingAxesUpdate ; bool DrawingSourcesUpdate ;
		void UpdateDrawingAxes()
		{
			var (added,removed) = DrawingAxesUpdate ; 
			//if( removed?.Count>0 ) foreach( var asp in draval ) foreach( var axe in removed ) asp.Axes.IndexWhere(a=>a.Spec==axe.Spec).nil(i=>i<0).Use(asp.Axes.RemoveAt) ; // removing is not applied to optimize reuse of axe
			if( added?.Count>0 ) foreach( var asp in draval ) { var asv = DrawingResources.One(a=>a.Spec==asp.Aspect) ; foreach( Axe axe in added ) if( asp.Axes.Any(a=>a.Spec==axe.Spec) ); else asp.Axes.Add((axe.Spec,asv[axe.Spec].ToArray(),axe.Base,asv.Offset)) ; }
			DrawingAxesUpdate = (null,null) ; if( added?.Count+removed?.Count>0 ) DrawingRange = null ;
		}
		void UpdateDrawingSources()
		{
			if( DrawingSourcesUpdate && DrawingResources is IEnumerable<Aspect> sources ) if( draval.Count<=0 || sources.Any(s=>!s.Regular) ) DrawingValue = null ; else
			{
				sources.Except(s=>s.Spec,draval.Select(s=>s.Aspect)).ToArray().Each(source=>draval.Add((source.Spec,source.Intersect(a=>a.Spec,draval[0].Axes.Select(x=>x.Spec)).Select(a=>(a.Spec,a.ToArray(),a.Base,source.Offset)).ToList()))) ;
				draval.Except(s=>s.Aspect,sources.Select(s=>s.Spec)).ToArray().Each(a=>draval.Remove(a)) ; DrawingRange = null ;
			}
			DrawingSourcesUpdate = false ;
		}
		#endregion
		List<(string Aspect,List<(string Spec,double?[] Val,string Base,double Offset)> Axes)> CalculateDrawingValue( Axe xaxe , string[] yaxes )
		{
			List<(string Aspect,List<(string Spec,double?[] Val,string Base,double Offset)> Axes)> val =
				DrawingResources.Select(asp=>(asp.Spec,asp.Where(a=>a.Spec==xaxe.Spec||yaxes.Contains(a.Spec)).Select(a=>(a.Spec,a.ToArray(),a.Base,asp.Offset)).ToList())).ToList() ;
			if( yaxes?.Any(y=>Aspect[y].Delta)==true && val.Count>1 )
			{
				var yma = yaxes.Where(yax=>Aspect[yax].Delta).ToArray() ; var mean = yma.ToDictionary(y=>y,y=>(val:0D,wei:0)) ;
				var ext = val.SelectMany(v=>v.Axes).Where(a=>yma.Contains(a.Spec)).Max(a=>a.Val.Length) ; var ixt = val.SelectMany(v=>v.Axes).Where(a=>yma.Contains(a.Spec)).Min(a=>a.Val.Length) ;
				foreach( var src in val ) for( var i=0 ; i<src.Axes.Count ; ++i ) if( yma.Contains(src.Axes[i].Spec) )
				{
					var off = (int)src.Axes[i].Offset ; if( off==0 ) continue ;
					var axv = src.Axes[i].Val ; if( off<0 ) for( var j=0 ; j<axv.Length ; ++j ) axv[j] = j-off<axv.Length ? axv[j-off] : null ; else for( var j=axv.Length-1 ; j>=0 ; --j ) axv[j] = j-off>=0 ? axv[j-off] : null ;
					src.Axes[i] = (src.Axes[i].Spec,src.Axes[i].Val,src.Axes[i].Base,0) ;
				}
				for( var i=0 ; i<ext ; ++i,yma.Each(k=>mean[k]=(0D,0)) )
				{
					foreach( var src in val ) foreach( var axe in src.Axes ) if( yma.Contains(axe.Spec) ) if( axe.Val.At(i) is double v ) mean[axe.Spec] = (mean[axe.Spec].val+v,mean[axe.Spec].wei+1) ;
					foreach( var src in val ) foreach( var axe in src.Axes ) if( yma.Contains(axe.Spec) ) if( i<axe.Val.Length ) axe.Val[i] -= i<ixt ? mean[axe.Spec].val/mean[axe.Spec].wei : null ;
				}
			}
			return val ;
		}
		async void GraphDrawAspect( bool crossed = true )
		{
			var axes = DrawingAxes ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 || AspectAxisGrid.SelectedItem is not Axe xaxe  ) return ;
			(double top,double left) = ViewOrigin = (ViewScreenMargin,ViewScreenMargin) ; (var width,var height) = ViewSize = ViewFrame.Size ;
			(var bot,var right) = (top+height,left+width) ; (var hor,var ver) = (right+left,bot+top) ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=hor ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = ver , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=ver ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = hor , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=hor ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = ver , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=ver ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = hor , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var val = DrawingValue ; if( val==null || yaxes.Any(y=>Aspect[y]?.Delta??false) ) await Task.Factory.StartNew(()=> val = DrawingValue = CalculateDrawingValue(xaxe,yaxes) ) ;
			var rng = DrawingRange ; if( rng==null )
			{
				DrawingRange = rng = new Dictionary<string,(double Min,double Max)>() ;
				foreach( var vax in val.SelectMany(s=>s.Axes) ) if( vax.Val.Where(v=>v!=null).Cast<double>().ToArray() is double[] a && a.Length>0 )
					rng[vax.Spec] = rng.ContainsKey(vax.Spec) ? rng[vax.Spec] = (Math.Min(rng[vax.Spec].Min,a.Min()),Math.Max(rng[vax.Spec].Max,a.Max())) : (a.Min(),a.Max()) ;
			}
			if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v ) => axe.Binder.No() ? Format(v) : axb.Of(v) ;
				for( var m=0 ; m<=hor ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterX(x.Min+(m-left)*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,ver-12);}) ) ;
				for( var m=50 ; m<=hor ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterX(x.Min+(m-left)*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,ver-20);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenInnerByRelAxeX(0D.By(x).Value) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = ver , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes) )
				{
					var y = rng[ax] ; axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=ver ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterY(y.Min+(bot-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-18);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenInnerByRelAxeY(0D.By(y,false).Value) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = hor , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			Dictionary<string,SolidColorBrush> coloring = null ;
			foreach( var asp in DrawingSources )
			{
				var asv = val.One(a=>a.Aspect==asp.Spec) ; var xax = asv.Axes.One(a=>a.Spec==xaxe.Spec) ; var color = new SolidColorBrush(Coloring(asp)) ; DoubleCollection dash ;
				if( coloring!=null || crossed && Focusation.Source!=null ) (coloring??=new Dictionary<string,SolidColorBrush>())[asp.Spec] = color ; // preparation for screen cross
				foreach( var ax in asv.Axes ) if( yaxes.Contains(ax.Spec) ) try
				{
					var ptss = new List<(int Count,int From)>() ; dash = null ;
					{
						int c,i,ac ; for( i=0 , c=0 , ac=ax.Val.Length ; i<ac ; ++i ) try { var stop = false ; if( xax.Val.At(i)!=null&&ax.Val.At(i)!=null ) ++c ; else stop = true ; if( stop||asp.Raw?[i]?.Mark==Mark.Stop ) { if( c>0 ) ptss.Add((c,i-c+(stop?0:1))) ; c = 0 ; } }
						catch( System.Exception e ) { Trace.TraceWarning($"Points calculation problem at {i}/{c}/{ac} : {e}") ; }
						if( c>0 ) ptss.Add((c,i-c)) ;
					}
					foreach( var pts in ptss ) GraphPanel.Children.Add( new Polyline{
						Stroke = color , StrokeDashArray = dash??=Array.IndexOf(yaxes,ax.Spec).Get(j=>j<1?null:new DoubleCollection{j}) ,
						Points = new PointCollection(pts.Count.Steps(pts.From).Select(i=>ScreenInnerByOuter((xax.Val[i].Value.By(rng[xax.Spec])*width??0)+ax.Offset,height-ax.Val[i].Value.By(rng[ax.Spec])*height??0)))
					} ) ;
					if( axes.One(a=>a.Spec==ax.Spec) is Path.Axe a && asp.Raw?.Corrections?.Base[a.Axis] is ISet<(int at,double value)> cors ) foreach( var cor in cors )
					{
						var p = ScreenInnerByOuter((xax.Val[cor.at].Value.By(rng[xax.Spec])*width??0)+ax.Offset,height-cor.value.By(rng[ax.Spec])*height??0) ;
						GraphPanel.Children.Add( new Polygon{
							Stroke = color , StrokeDashArray = dash??=Array.IndexOf(yaxes,ax.Spec).Get(j=>j<1?null:new DoubleCollection{j}) ,
							Points = new PointCollection{ p+new Vector(-Math.Sqrt(3),-1) , p+new Vector(Math.Sqrt(3),-1) , p+new Vector(0,2) }
						} ) ;
					}
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; } dash = null ;
				foreach( var (No,Tags,At) in asp.Raw?.Where(p=>!p.Tags.No()).Select(p=>(p.No,p.Tags,p[xax.Base])) ) if( No is int no && (At??xax.Val.At(no)) is double at && ScreenInnerByOuterX((at.By(rng[xax.Spec])*width??0)+asp.Offset) is double x )
				{
					GraphPanel.Children.Add( new Label{ Content=Tags , Foreground=color , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,9*SourceIndex(asp)-9);Canvas.SetLeft(l,x-3);}) ) ; // point tag
					GraphPanel.Children.Add( new Line{ X1 = x , Y1 = 0 , X2 = x , Y2 = ver , Stroke = color , StrokeDashArray = dash??=new DoubleCollection{2,6} } ) ; // tag line
				}
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			Hypercube.Each(e=>Coordinates+=co[e.Key].One().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
			if( crossed && Focusation.Source!=null ) foreach( var foc in Focusation.Source ) if( foc.At is int fo && (val.at(a=>a.Aspect==foc.Spec)??val[0]) is var src && -1 is int ay && 0D is double fx && coloring.By(src.Aspect) is SolidColorBrush cof ) foreach( var cor in Coordinates )
			{
				if( ++ay>=0 && ( cor.Value = src.Axes.at(a=>a.Spec==cor.Axe)?.Val.At(fo) ) is double fa )
				if( ay==0 ) fx = fa ; else if( ay==1 )
				{
					ScreenCrossing = (ScreenInnerByRelAxe(fx.By(rng[xaxe.Spec]).Value,fa.By(rng[cor.Axe],false).Value),cof) ;
					GraphPanel.Children.Add( new Label{ Content=Coordinates[c=>c.Axe==xaxe.Spec].View , Foreground=Brushes.Orange , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,-6);Canvas.SetLeft(l,ScreenCrossing.Value.at.X-2);}).Set(ScreenCross.Val.Add) ) ;
					if( cor.View is string ylab ) GraphPanel.Children.Add( new Label{ Content=ylab , Foreground=cof , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,ScreenCrossing.Value.at.Y-17);Canvas.SetLeft(l,hor-7-ylab.Length*6);}).Set(ScreenCross.Val.Add) ) ;
				}
				else
				{
					var sy = ScreenInnerByRelAxeY(fa.By(rng[cor.Axe],false).Value) ;
					GraphPanel.Children.Add( new Line{ Stroke=cof , X1=0 , X2=MainFrameSize.Width , Y1=sy , Y2=sy , StrokeThickness=0.4+0.3*(Coordinates.Count-ay)/Coordinates.Count }.Set(ScreenCross.Axe.Add) ) ;
					if( cor.View is string ylab ) GraphPanel.Children.Add( new Label{ Content=ylab , Foreground=cof , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,sy-17);Canvas.SetLeft(l,hor-7-ylab.Length*6);}).Set(ScreenCross.Val.Add) ) ;
				}
			}
		}
		async void MapDrawAspect( bool crossed = true )
		{
			var axes = DrawingAxes ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; if( yaxes.Length<1 || AspectAxisGrid.SelectedItem is not Axe xaxe  ) return ;
			(var top,var left) = ViewOrigin = (ViewScreenMargin, ViewScreenMargin) ; (var width,var height) = ViewSize = ViewFrame.Size ; // Margin adjustion
			(var bot,var right) = (top+height,left+width) ; (var hor,var ver) = (right+left,bot+top) ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=200,G=200,B=200}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=hor ; m+=50 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = ver , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=ver ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = hor , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=hor ; m+=10 ) MapPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = ver , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=ver ; m>=0 ; m-=10 ) MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = hor , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var val = DrawingValue ; if( val==null || yaxes.Any(y=>Aspect[y]?.Delta??false) ) await Task.Factory.StartNew(()=> val = DrawingValue = CalculateDrawingValue(xaxe,yaxes) ) ;
			var rng = DrawingRange ; if( rng==null )
			{
				DrawingRange = rng = new Dictionary<string,(double Min,double Max)>() ;
				foreach( var vax in val.SelectMany(s=>s.Axes) ) if( vax.Val.Where(v=>v!=null).Cast<double>().ToArray() is double[] a && a.Length>0 )
					rng[vax.Spec] = rng.ContainsKey(vax.Spec) ? rng[vax.Spec] = (Math.Min(rng[vax.Spec].Min,a.Min()),Math.Max(rng[vax.Spec].Max,a.Max())) : (a.Min(),a.Max()) ;
			}
			if( !rng.ContainsKey(xaxe.Spec) ) return ;
			{
				var x = rng[xaxe.Spec] ; var axe = xaxe ; Filter.Entry.Binding axb = axe.Binder ; string format( double v , int p ) => axe.Binder.No() ? Format(v,p) : axb.Of(v) ;
				for( var m=0 ; m<=hor ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterX(x.Min+(m-left)*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,ver-12);}) ) ;
				for( var m=50 ; m<=hor ; m+=100 ) MapPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterX(x.Min+(m-left)*(x.Max-x.Min)/width,x),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,ver-20);}) ) ;
				if( x.Min<0 && x.Max>0 ) { var xZero = ScreenInnerByRelAxeX(0D.By(x).Value) ; MapPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = ver , Stroke = Brushes.Gray } ) ; }
				var n=0 ; foreach( var ax in rng.Keys.Intersect(yaxes.Take(1)) )
				{
					var y = rng[ax] ; axe = axes.FirstOrDefault(a=>a.Spec==ax) ; axb = axe.Binder ;
					for( var m=ver ; m>=0 ; m-=50 ) MapPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterY(y.Min+(bot-m)*(y.Max-y.Min)/height,y),5) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-18);Canvas.SetLeft(l,n*50-4);}) ) ; ++n ;
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenInnerByRelAxeY(0D.By(y,false).Value) ; MapPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = hor , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
			}
			(double X,double Y) sha = ((Coordinates.FirstOrDefault(c=>c.Axe==xaxe.Spec)?.Info??State.Coordination(xaxe.Spec)).Evaluate()??0,(Coordinates.FirstOrDefault(c=>c.Axe==yaxes[0])?.Info??State.Coordination(yaxes[0])).Evaluate()??0) ;
			var zis = Math.Pow(Math.Sqrt(width*height),1D/3D) ; var shift = 0 ; var zi = Setup.PrimaryShape ;
			foreach( var asp in DrawingSources )
			{
				var asv = val.One(a=>a.Aspect==asp.Spec) ; var xax = asv.Axes.One(a=>a.Spec==xaxe.Spec) ; var yax = asv.Axes.One(a=>a.Spec==yaxes[0]) ;
				var pts =new List<(System.Windows.Point A,System.Windows.Point B,Mark S,double? X,double? Y,(string Spec,double? Val)[] Z,string T)>() ; var zaxes = yaxes.Skip(1).Select(z=>asv.Axes.One(a=>a.Spec==z)).ToArray() ;
				for( int i=0 , c = asp.Points.Count-1 ; i<c ; ++i ) if( xax.Val[i]!=null && yax.Val[i]!=null && xax.Val[i+1]!=null && yax.Val[i+1]!=null && !asp.Raw[i].Mark.HasFlag(Mark.Stop) ) try
				{
					var spt0 = ScreenInnerByOuter(xax.Val[i].Value.By(rng[xax.Spec])*width??0,height-yax.Val[i].Value.By(rng[yax.Spec])*height??0) ;
					var spt1 = ScreenInnerByOuter(xax.Val[i+1].Value.By(rng[xax.Spec])*width??0,height-yax.Val[i+1].Value.By(rng[yax.Spec])*height??0) ;
					if( spt0.X>=0 && spt0.Y>=0 && spt1.X<=hor && spt1.Y<=ver ) pts.Add((spt0,spt1,asp.Raw[i+1].Mark,xax.Val[i],yax.Val[i],zaxes.Select(z=>(z.Spec,z.Val[i])).ToArray(),asp.Raw[i+1].Tags)) ;
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				for( var i=1 ; i<yaxes.Length ; ++i ) rng[yaxes[i]]=(pts.Min(p=>p.Z[i-1].Val).Value,pts.Max(p=>p.Z[i-1].Val).Value) ;
				var color = Coloring(asp) ; (double dx,double dy) lv = (0,0) ;
				foreach( var (A,B,S,X,Y,Z,T) in pts ) try
				{
					var za = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)).ToArray() ; var zb = Z.Select(z=>Coordinates.FirstOrDefault(c=>c.Axe==z.Spec)?.Info??State.Coordination(z.Spec)).ToArray() ;
					var zicol = Z.At((zi+1)%2).nil(z=>z.Spec==null) ; var ziaro = Z.At(zi%2).nil(z=>z.Spec==null) ;
					var axcol = zicol.Get(z=>(z.Val-(zb.At((zi+1)%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At((zi+1)%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					var axaro = ziaro.Get(z=>(z.Val-(zb.At(zi%2)?.Byte<0?rng[z.Spec].Max:rng[z.Spec].Min))/(zb.At(zi%2)?.Byte??rng[z.Spec].Max-rng[z.Spec].Min).nil())-asp.Offset ;
					if( axcol<zb.At((zi+1)%2)?.Count-za.At((zi+1)%2)?.Size || axaro<zb.At(zi%2)?.Count-za.At(zi%2)?.Size ) continue ;
					var zisc = axcol==null && zicol?.Spec is string sp ? rng[sp].Min : zis ;
					var axarow = ziaro.use(z=>(axaro*zisc%zisc).Signate(zb.At(zi%2)?.Reverse==false?zisc:null as double?)??rng[z.Spec].Min) ;
					double x1 = A.X+shift*sha.X , y1 = A.Y+shift*sha.Y , x2 = B.X+shift*sha.X , y2 = B.Y+shift*sha.Y , ln = Math.Sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)) ; if( ln>0 ) lv = ((x2-x1)/ln,(y2-y1)/ln) ;
					MapPanel.Children.Add( new Line{ X1 = x1 , Y1 = y1 , X2 = x2 , Y2 = y2 ,
						Stroke = axcol.Get(z=>new SolidColorBrush(color*(float)(z%1*.75+.25).Signate(zb.At((zi+1)%2)?.Reverse==false?1:null as double?))) ?? new SolidColorBrush(color) ,
						StrokeThickness = axarow ?? ( axcol==null && (zicol?.Spec??ziaro?.Spec) is string spec ? rng[spec].Min : 1 ) ,
					} ) ;
					if( S.HasFlag(Mark.Stop) ) MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-lv.dy*zis , Y2 = y2+lv.dx*zis , Stroke = Brushes.Gray , StrokeThickness = 1 } ) ; // stop mark
					if( S.HasFlag(Mark.Lap) )
					{
						MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-(lv.dx-lv.dy)*Lape*zis , Y2 = y2-(lv.dx+lv.dy)*Lape*zis , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // lap mark
						MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-(lv.dx+lv.dy)*Lape*zis , Y2 = y2+(lv.dx-lv.dy)*Lape*zis , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // lap mark
					}
					if( S.HasFlag(Mark.Sub) )
					{
						MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-(lv.dx-lv.dy)*Lape*zis/2 , Y2 = y2-(lv.dx+lv.dy)*Lape*zis/2 , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // sub mark
						MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-(lv.dx+lv.dy)*Lape*zis/2 , Y2 = y2+(lv.dx-lv.dy)*Lape*zis/2 , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // sub mark
					}
					if( S.HasFlag(Mark.Ato) ) MapPanel.Children.Add( new Line{ X1 = x2 , Y1 = y2 , X2 = x2-(lv.dx+lv.dy)*Lape*zis/2 , Y2 = y2+(lv.dx-lv.dy)*Lape*zis/2 , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // ato mark
					if( S.HasFlag(Mark.Sup) )
					{
						//MapPanel.Children.Add( new Line{ X1 = x2-lv.dy*zis/2 , Y1 = y2+lv.dx*zis/2 , X2 = x2-(lv.dy+(lv.dx-lv.dy)*Lape)*zis/2 , Y2 = y2+(lv.dx-(lv.dx+lv.dy)*Lape)*zis/2 , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // sup mark
						MapPanel.Children.Add( new Line{ X1 = x2-lv.dy*zis/2 , Y1 = y2+lv.dx*zis/2 , X2 = x2-(lv.dy+(lv.dx+lv.dy)*Lape)*zis/2 , Y2 = y2+(lv.dx+(lv.dx-lv.dy)*Lape)*zis/2 , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // sup mark
					}
					if( S.HasFlag(Mark.Hyp) )
					{
						//MapPanel.Children.Add( new Line{ X1 = x2-lv.dy*zis , Y1 = y2+lv.dx*zis , X2 = x2-(lv.dy+(lv.dx-lv.dy)*Lape)*zis , Y2 = y2+(lv.dx-(lv.dx+lv.dy)*Lape)*zis , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // hyp mark
						MapPanel.Children.Add( new Line{ X1 = x2-lv.dy*zis , Y1 = y2+lv.dx*zis , X2 = x2-(lv.dy+(lv.dx+lv.dy)*Lape)*zis , Y2 = y2+(lv.dx+(lv.dx-lv.dy)*Lape)*zis , Stroke = Brushes.Black , StrokeThickness = 1 } ) ; // hyp mark
					}
					if( T.Void() );else MapPanel.Children.Add(new Label{ Content=T , Foreground=Brushes.Gray , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,y2-4);Canvas.SetLeft(l,x2-2);})) ; // point tag
					if( axcol>zb.At((zi+1)%2)?.Count || axaro>zb.At(zi%2)?.Count )
					{
						foreach( var v in Z ) Coordinates.FirstOrDefault(c=>c.Axe==v.Spec).Set(c=>c.Value=v.Val) ;
						Coordinates.FirstOrDefault(c=>c.Axe==xax.Spec).Set(c=>c.Value=X) ; Coordinates.FirstOrDefault(c=>c.Axe==yax.Spec).Set(c=>c.Value=Y) ;
						break ;
					}
				}
				catch( System.Exception ex ) { Trace.TraceWarning(ex.Stringy()) ; }
				++shift ;
			}
			Hypercube = rng.Where(a=>xaxe.Spec==a.Key||yaxes.Contains(a.Key)).OrderBy(e=>e.Key==xaxe.Spec?0:Array.IndexOf(yaxes,e.Key)+1).ToArray() ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			Hypercube.Each(e=>Coordinates+=co[e.Key].One().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key)?.Binder}) ;
			if( crossed ) if( Focusation.Source.At(0).At is int fo && val[0].Axes.FirstOrDefault(a=>a.Spec==xaxe.Spec).Val.At(fo) is double fx && val[0].Axes.FirstOrDefault(a=>a.Spec==yaxes[0]).Val.At(fo) is double fy )
			{
				foreach( var cor in Coordinates ) cor.Value = val[0].Axes.FirstOrDefault(a=>a.Spec==cor.Axe).Val.At(fo) ;
				ScreenCrossing = (ScreenInnerByRelAxe(fx.By(rng[xaxe.Spec]).Value,fy.By(rng[yaxes[0]],false).Value),Brushes.Orange) ;
				MapPanel.Children.Add( new Label{ Content=Coordinates[c=>c.Axe==xaxe.Spec].View , Foreground=Brushes.Orange , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,-6);Canvas.SetLeft(l,ScreenCrossing.Value.at.X-2);}).Set(ScreenCross.Val.Add) ) ;
				if( Coordinates[c=>c.Axe==yaxes[0]]?.View is string ylab ) MapPanel.Children.Add( new Label{ Content=ylab , Foreground=Brushes.Orange , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,ScreenCrossing.Value.at.Y-17);Canvas.SetLeft(l,hor-2-ylab.Length*6);}).Set(ScreenCross.Val.Add) ) ;
				if( Coordinates[c=>c.Axe==yaxes.At(1)]?.View is string zlab ) MapPanel.Children.Add( new Label{ Content=zlab , Foreground=Brushes.Orange , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,ScreenCrossing.Value.at.Y-17);Canvas.SetLeft(l,ScreenCrossing.Value.at.X-2);}).Set(ScreenCross.Val.Add) ) ;
				if( Coordinates[c=>c.Axe==yaxes.At(2)]?.View is string alab ) MapPanel.Children.Add( new Label{ Content=alab , Foreground=Brushes.Orange , FontStyle=FontStyles.Italic }.Set(l=>{Canvas.SetTop(l,ScreenCrossing.Value.at.Y-5);Canvas.SetLeft(l,ScreenCrossing.Value.at.X-2);}).Set(ScreenCross.Val.Add) ) ;
			}
			else ScreenCrossing = ScreenCrossing ;
		}
		static readonly double Lape = Math.Cos(Math.PI/4) ;
		async void GraphDrawQuantile()
		{
			(double top,double left) = ViewOrigin = (ViewScreenMargin, ViewScreenMargin) ; (var width,var height) = ViewSize = ViewFrame.Size ;
			(var bot,var right) = (top+height,left+width) ; (var hor,var ver) = (right+left,bot+top) ;
			{
				var brush = new SolidColorBrush(new Color{A=127,R=127,G=127,B=127}) ; var dash = new DoubleCollection{4} ;
				for( var m=0 ; m<=hor ; m+=50 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = ver , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=ver ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = hor , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
				brush = new SolidColorBrush(new Color{A=63,R=191,G=191,B=191}) ; dash = new DoubleCollection{8} ;
				for( var m=0 ; m<=hor ; m+=10 ) GraphPanel.Children.Add( new Line{ X1 = m , Y1 = 0 , X2 = m , Y2 = ver , Stroke = brush , StrokeDashArray = dash } ) ;
				for( var m=ver ; m>=0 ; m-=10 ) GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = m , X2 = hor , Y2 = m , Stroke = brush , StrokeDashArray = dash } ) ;
			}
			var axes = DrawingAxes ; var yaxes = axes.Skip(1).Select(a=>a.Spec).ToArray() ; var selas = DrawingSources.ToArray() ; var relas = DrawingResources.ToArray() ; var rng = new List<KeyValuePair<string,(double Min,double Max)>>() ; var k = 0 ;
			foreach( var axe in Quantiles ) if( axe.Spec!=null && QuantileData.At(axe.Spec) is Quantilable ax && await ax.Count()>0 && yaxes.Contains(axe.Spec) )
			{
				var axa = ax.Ax ; Filter.Entry.Binding axb = axa.Binder ; string format( double v ) => (axa?.Binder).No() ? Format(v) : axb.Of(v) ;
				var val = ax.SelectMany(v=>v.Skip(1)) ; ((double Min,double Max) x,(double Min,double Max) y) = ((ax.Min(a=>a[0]),ax.Max(a=>a[0])),(val.Min(),val.Max())) ;
				rng.Add(new KeyValuePair<string,(double Min,double Max)>(ax.Ax.Spec,x)) ; rng.Add(new KeyValuePair<string,(double Min,double Max)>($"Q({ax.Ax.Spec}){ax.Axon?.Spec}",y)) ;
				{
					for( var m=0 ; m<=hor ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterX(x.Min+(m-left)*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,ver-10-10*k);}) ) ;
					for( var m=50 ; m<=hor ; m+=100 ) GraphPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterX(x.Min+(m-left)*(x.Max-x.Min)/width,x)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetLeft(l,m-5);Canvas.SetTop(l,ver-20-10*k);}) ) ;
					axa = ax.Axon ; axb = ax.Axon?.Binder ; for( var m=ver ; m>=0 ; m-=50 ) GraphPanel.Children.Add( new Label{ Content=format(AxeInnerByOuterY(y.Min+(bot-m)*(y.Max-y.Min)/height,y)) , Foreground=Brushes.Gray }.Set(l=>{Canvas.SetTop(l,m-18);Canvas.SetLeft(l,-4);}) ) ;
					if( x.Min<0 && x.Max>0 ) { var xZero = ScreenInnerByRelAxeX(0D.By(x).Value) ; GraphPanel.Children.Add( new Line{ X1 = xZero , Y1 = 0 , X2 = xZero , Y2 = ver , Stroke = Brushes.Gray } ) ; }
					if( y.Min<0 && y.Max>0 ) { var yZero = ScreenInnerByRelAxeY(0D.By(y,false).Value) ; GraphPanel.Children.Add( new Line{ X1 = 0 , Y1 = yZero , X2 = hor , Y2 = yZero , Stroke = Brushes.Gray } ) ; }
				}
				if( x.Max!=x.Min && y.Max!=y.Min ) for( int j = 1 , cnt = ax.One()?.Length??0 ; j<cnt ; ++j ) if( selas.Contains(relas[j-1]) ) GraphPanel.Children.Add( new Polyline{
					Stroke = new SolidColorBrush( Coloring(relas[j-1]/* is Aspect asp?SourceIndex(asp):j-1)*/) ) , StrokeDashArray = k==0?null:new DoubleCollection{k} ,
					Points = new PointCollection(ax.Select(a=>ScreenInnerByOuter(a[0].By(x).Value*width,height-a[j].By(y).Value*height)))
				} ) ;
				++k ;
			}
			Hypercube = rng ; var co = Coordinates.ToLookup(c=>c.Axe) ; Coordinates.Clear() ;
			rng.Each(e=>Coordinates+=co[e.Key].One().Set(c=>{c.Range=e.Value;c.Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder;})??new Coordinate(this,e.Key){Range=e.Value,Bond=axes.FirstOrDefault(a=>a.Spec==e.Key||a.Spec==e.Key.RightFrom(')'))?.Binder}) ;
		}
		#endregion

		static int DecDigits( double value , int prec = 3 ) => value==0 ? 0 : (int)Math.Max(0,prec-Math.Log10(Math.Abs(value))) ;
		static string Format( double value , int prec = 3 ) => value.ToString("#."+new string('#',DecDigits(value,prec))) ;
		IEnumerable<KeyValuePair<string,(double Min,double Max)>> Hypercube ; (double Width,double Height) ViewSize , ViewOrigin ; (Line X,Line Y) MouseCross ; (IList<Line> Axe,IList<Label> Val) ScreenCross = (new List<Line>(),new List<Label>()) ;
		(double Width,double Height) ViewScreenBorder => (DisplayTable.Margin.Left+DisplayTable.Margin.Right+4,30) ;
		static readonly Color[] Colos = new[]{ new Color{A=255,R=255,G=0,B=0} , new Color{A=255,R=0,G=200,B=0} , new Color{A=255,R=0,G=0,B=255} , new Color{A=255,R=191,G=191,B=0} , new Color{A=255,R=0,G=191,B=191} , new Color{A=255,R=191,G=0,B=191} , new Color{A=255,R=223,G=159,B=0} , new Color{A=255,R=159,G=223,B=0} , new Color{A=255,R=0,G=223,B=159} , new Color{A=255,R=0,G=159,B=223} , new Color{A=255,R=159,G=0,B=223} , new Color{A=255,R=223,G=0,B=159} } ;
		static readonly FontStretch[] Fostres = new[]{ FontStretches.UltraExpanded , FontStretches.ExtraExpanded , FontStretches.Expanded , FontStretches.SemiExpanded , FontStretches.Normal , FontStretches.SemiCondensed , FontStretches.Condensed , FontStretches.ExtraCondensed , FontStretches.UltraCondensed } ;
		static readonly FontWeight[] Foweis = new[]{ /*FontWeights.ExtraBlack , FontWeights.Black ,*/ FontWeights.ExtraBold , FontWeights.Bold , FontWeights.SemiBold , FontWeights.Medium , FontWeights.Normal , FontWeights.Light , FontWeights.ExtraLight , FontWeights.Thin } ;
        static Color Coloring( int index ) => index<0 ? Colors.Black : Colos[index%Colos.Length] ;
        static bool RefontAxes( object sender )
		{
			var success = true ; if( sender is not DataGrid grid ) return success ; var gen = grid.ItemContainerGenerator ; var sel = grid.SelectedItem ; int ix = 0 ; var sels = grid.SelectedItems.OfType<Axe>().ToArray() ;
			foreach( var item in sels )
			{
				/*grid.ScrollIntoView(item) ;*//*Incomfortable*/ if( gen.ContainerFromItem(item) is not DataGridRow row ) continue ;
				if( row.Cell(0) is DataGridCell cell )
				{
					cell.FontStyle = sel==item?FontStyles.Normal:FontStyles.Italic ; cell.FontStretch = item==sel?FontStretches.Normal:Fostres[ix%Fostres.Length] ; cell.FontWeight = item==sel?FontWeights.Bold:Foweis[ix%Foweis.Length] ; if( item!=sel ) ++ix ;
				}
				else success = false ;
			}
			foreach( var item in grid.Items.OfType<Axe>().Except(sels) )
			{
				/*grid.ScrollIntoView(item) ;*//*Incomfotable*/ if( gen.ContainerFromItem(item) is not DataGridRow row ) continue ;
				if( row.Cell(0) is DataGridCell cell && row.Cell(1) is DataGridCell coll ) { cell.FontStyle = coll.FontStyle ; cell.FontStretch = coll.FontStretch ; cell.FontWeight = coll.FontWeight ; } else success = false ;
			}
			return success ;
		}

		#region Coordinates
		void Main_MouseMove( object sender , MouseEventArgs e ) => MousePoint = Mouse.GetPosition(ViewPanel) ;
		public class Coordinate : INotifyPropertyChanged
		{
			readonly Main Context ;
			public event PropertyChangedEventHandler PropertyChanged ;
			public Coordinate( Main context , string axe ) => Info = (_byte = (Context = context).State[Axe = axe]).ParseCoinfo() ;
			public string Axe { get; }
			public double? Value { get => value ; internal set { this.value = value ; PropertyChanged.On(this,"Value,View") ; } } double? value ;
			public string View => Binding.Of(value) ;
			public string Byte { get => _byte ; set { if( Byte==value ) return ; Context.State[Axe] = _byte = value ; Info = value.ParseCoinfo() ; PropertyChanged.On(this,"Byte") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; } } string _byte ;
			public (double? Byte,uint? Count,bool Reverse)? Info { get => info ?? Context.State.Coordination(Axe) ; set { if( info.Equals(value) ) return ; info = value ; Byte = value.StringCoinfo() ; } } (double? Byte,uint? Count,bool Reverse)? info ;
			public (double Min,double Max) Range ;
			public string Bond { set => Binding = value ; } Filter.Entry.Binding Binding ;
			public string At { get => at ; set { if( value==at ) return ; Size = (at=value).Parse<uint>() ; PropertyChanged.On(this,"At") ; } } string at ;
			public uint? Size { get => size ; set { if( value==size ) return ; size = value ; PropertyChanged.On(this,"Size") ; if( Context.MapTab.IsSelected ) Context.Map_Draw(Context) ; At = value.Stringy() ; } } uint? size ;
		}
		void CoordinatesGrid_MouseRightButtonUp( object sender, MouseButtonEventArgs e )
		{
			if( sender is not DataGrid grid ) return ; var state = grid.Columns[2].Visibility==Visibility.Visible ;
			grid.Columns[2].Visibility = state ? Visibility.Collapsed : Visibility.Visible ; grid.Columns[3].Visibility = state ? Visibility.Collapsed : Visibility.Visible ;
			grid.Columns[1].Width = state ? new DataGridLength(1,DataGridLengthUnitType.Star) : DataGridLength.Auto ;
		}
		public Aid.Collections.ObservableList<Coordinate> Coordinates {get;private set;} = new Aid.Collections.ObservableList<Coordinate>() ;
		public System.Windows.Point? MousePoint
		{
			get => mousePoint ; set
			{
				MouseCross.X.Set(ViewPanel.Children.Remove) ; MouseCross.Y.Set(ViewPanel.Children.Remove) ; if( value is not System.Windows.Point point ) return ;
				if( point.X<0 ) point.X = 0 ; if( point.Y<0 ) point.Y = 0 ; var maf = MainFrameSize ; if( point.X>maf.Width ) point.X = maf.Width ; if( point.Y>maf.Height ) point.Y = maf.Height ;
				var asp = Hypercube is Array ; PropertyChanged.On( this, "MousePoint", (mousePoint=point).Use(m=>Hypercube.Each(a=>CoordinateSet(m,a,asp))) ) ;
				ViewPanel.Children.Add( MouseCross.X = new Line{ Stroke=Brushes.Gray , X1=0 , X2=maf.Width , Y1=point.Y , Y2=point.Y } ) ;
				ViewPanel.Children.Add( MouseCross.Y = new Line{ Stroke=Brushes.Gray , Y1=0 , Y2=maf.Height , X1=point.X , X2=point.X } ) ;
			}
		}
		void CoordinateSet( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a , bool asp )
		{
			var co = Coordinates.First(c=>c.Axe==a.Key) ; co.Value = ( asp ? AspectAxisGrid.SelectedItem is Axe x && a.Key==x.Spec : !a.Key.StartsBy("Q(") ) ?
			AxeInnerByOuterX(AxeXByMouse(m,a),a.Value) : ViewPanel==GraphPanel || Coordinates.IndexOf(co)<2 ? AxeInnerByOuterY(AxeYByMouse(m,a),a.Value) : AxeZByMouse(a.Key) ;
		}
		void CorrectionSet()
		{
			if( MousePoint is not System.Windows.Point point ) return ; bool redraw = false ;
			if( Hypercube is KeyValuePair<string,(double Min,double Max)>[] hyp && hyp.Length==2 ) foreach( var asp in Resources ) if( asp[hyp[1].Key] is Path.Axe y && asp[hyp[0].Key] is Path.Axe x )
				if( x.AtOf(AxeInnerByOuterX(AxeXByMouse(point,hyp[0]),hyp[0].Value)) is int at ) { asp.Raw.Correction[y.Axis] = (at,AxeInnerByOuterY(AxeYByMouse(point,hyp[1]),hyp[1].Value)) ; redraw = true ; }
			if( redraw ) Redraw() ;
		}
		void TransitionSet()
		{
			if( MousePoint is System.Windows.Point point && Hypercube is KeyValuePair<string,(double Min,double Max)>[] hyp && hyp.Length>0 ); else return ;
			IList<(string Axe,double Value)> value = new List<(string Axe,double Value)>() ; var map = MapTab.IsSelected ; for( var i=0 ; i<hyp.Length ; ++i )
				if( i==0 ) value.Add((hyp[i].Key,AxeInnerByOuterX(AxeXByMouse(point,hyp[i]),hyp[i].Value))) ;
				else if( i==1 ) value.Add((hyp[i].Key,AxeInnerByOuterY(AxeYByMouse(point,hyp[i]),hyp[i].Value))) ;
				//else if( map && AxeZByMouse(hyp[i].Key) is double v ) value.Add((hyp[i].Key,v)) ;
			//foreach( var asp in Resources ) if( asp.AtOf(value)?.at is int at ) { Focusation.Source = (at,asp.Spec) ; return ; }
			Focusation.Source = Resources.Select(r=>(r.AtOf(value)?.at,r.Spec)).ToArray() ;
		}
		#region Focusation
		((int? At,string Spec)[] Source,Dictionary<object,DataGrid> Grid,DataGridRow Row) Focusation = (null,new Dictionary<object,DataGrid>(),null) ;
		void TabItem_MouseLeftButtonUp( object sender , MouseButtonEventArgs e ) { if( sender is TabItem tab && Focusation.Source.At(0).At is int at && Focusation.Grid.By(tab.Content) is DataGrid grid ) Highlight(grid,at,Focusation.Row) ; }
		//void Highlight( DataGrid grid , int at ) { grid.SelectedIndex = at ; grid.Focus() ; grid.ScrollIntoView(grid.SelectedItem) ; } // Slection variant
		void Highlight( DataGrid grid , int at , DataGridRow old = null ) { grid.Focus() ; grid.ScrollIntoView(grid.Items[at]) ; if( old is DataGridRow row ) row.Background = Brushes.Transparent ; if( grid.ItemContainerGenerator.ContainerFromIndex(at) is DataGridRow cont ) (Focusation.Row=cont).Background = Brushes.Orange ; }
		void DataGrid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( sender is not DataGrid grid ) return ; if( grid.SelectedItem==null ) ScreenCrossing = null ; Focusation.Source = new[]{(grid.SelectedIndex.nil(v=>v<0),null as string)} ; }
		#endregion
		double AxeXByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => (m.X-ViewOrigin.Width)/ViewSize.Width*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double AxeYByMouse( System.Windows.Point m , KeyValuePair<string,(double Min,double Max)> a ) => (ViewSize.Height+ViewOrigin.Height-m.Y)/ViewSize.Height*(a.Value.Max-a.Value.Min)+a.Value.Min ;
		double? AxeZByMouse( string a )
		{
			var x = Coordinates[0]?.Value ; var y = Coordinates[1]?.Value ; var ax = Coordinates[0]?.Axe ; var ay = Coordinates[1]?.Axe ; Aspect.Point? op = null ; double? ov = null , cv ;
			foreach( var src in DrawingSources ) foreach( var pt in src.Points ) if( (cv=(pt[ax]-x).Sqr()+(pt[ay]-y).Sqr())<ov || ov==null ) { op = pt ; ov = cv ; }
			return op?[a] ;
		}
		#endregion

		#region Focusing
		System.Windows.Point? mousePoint , screenPoint ; Rect? ScreenRect ; (System.Windows.Point at,Brush color)? screenCrossing ;
		System.Windows.Point? ScreenOrigin { get => screenPoint ; set { ScreenCrossing = null ; screenPoint = value.Get(_=>ScreenMouse) ; if( value!=null ) { ScreenCrossing = (value.Value,Brushes.Orange) ; TransitionSet() ; } } }
		(System.Windows.Point at,Brush color)? ScreenCrossing
		{
			get => screenCrossing ;
			set
			{
				if( (screenCrossing=value) is (System.Windows.Point at,Brush color) cross )
				{
					ViewPanel.Children.Add( new Line{ Stroke=cross.color , X1=0 , X2=MainFrameSize.Width , Y1=cross.at.Y , Y2=cross.at.Y , StrokeThickness=0.5 }.Set(ScreenCross.Axe.Add) ) ;
					ViewPanel.Children.Add( new Line{ Stroke=Brushes.Orange , Y1=0 , Y2=MainFrameSize.Height , X1=cross.at.X , X2=cross.at.X , StrokeThickness=0.5 }.Set(ScreenCross.Axe.Add) ) ;
				}
				else { ScreenCross.Axe.Each(ViewPanel.Children.Remove) ; ScreenCross.Val.Each(ViewPanel.Children.Remove) ; ScreenCross.Axe.Clear() ; ScreenCross.Val.Clear() ; }
			}
		}
		System.Windows.Point? ScreenMouse { get { if( ScreenRect==null || MousePoint==null ) return MousePoint ; (var width,var height) = MainFrameSize ; var p = MousePoint.Value ; var r = ScreenRect.Value ; return new System.Windows.Point(p.X*r.Size.Width/width+r.Location.X,p.Y*r.Size.Height/height+r.Location.Y) ; } }
		void ViewPanel_MouseDown( object sender , MouseButtonEventArgs e ) { /*if( Keyboard.Modifiers==ModifierKeys.None )*/ ScreenOrigin = MousePoint ; if( MousePoint is System.Windows.Point && Keyboard.Modifiers==ModifierKeys.Control ) CorrectionSet() ; }
		void DisplayTable_MouseUp( object sender , MouseButtonEventArgs e ) { if( ScreenMouse==ScreenOrigin || Keyboard.Modifiers!=ModifierKeys.None ) return ; var scr = ScreenOrigin.Get(s=>ScreenMouse.use(p=>new Rect(s,p))) ; if( scr==ScreenRect ) return ; ScreenRect = scr ; if( GraphTab.IsSelected ) Graph_Draw(sender) ; if( MapTab.IsSelected ) Map_Draw(sender) ; }
		void DisplayTable_MouseDoubleClick( object sender = null , MouseButtonEventArgs e = null ) { var nocros = ScreenRect==null ; ScreenOrigin = null ; ScreenRect = null ; DisplayTable_MouseRightButtonDown(nocros?null:sender) ; }
		void DisplayTable_MouseRightButtonDown( object sender = null , MouseButtonEventArgs e = null ) { if( GraphTab.IsSelected ) Graph_Draw(sender,e) ; else if( MapTab.IsSelected ) Map_Draw(sender,e) ; }
		System.Windows.Point ScreenInnerByOuter( double x , double y ) => new(ScreenInnerByOuterX(x),ScreenInnerByOuterY(y)) ;
		System.Windows.Point ScreenInnerByRelAxe( double x , double y ) => new(ScreenInnerByRelAxeX(x),ScreenInnerByRelAxeY(y)) ;
		double ScreenInnerByOuterX( double x ) => ( ScreenRect is Rect r ? (x+ViewOrigin.Width-r.Location.X)*ViewSize.Width/r.Size.Width : x ) + ViewOrigin.Width ;
		double ScreenInnerByRelAxeX( double x ) => ScreenInnerByOuterX(x*ViewSize.Width) ;
		double ScreenInnerByOuterY( double y ) => ( ScreenRect is Rect r ? (y+ViewOrigin.Height-r.Location.Y)*ViewSize.Height/r.Size.Height : y ) + ViewOrigin.Height ;
		double ScreenInnerByRelAxeY( double x ) => ScreenInnerByOuterY(x*ViewSize.Height) ;
		double AxeInnerByOuterX( double x , (double Min,double Max) e ) { if( ScreenRect is not Rect r ) return x ; var q = (e.Max-e.Min)/ViewSize.Width ; var fx = (x-e.Min)/q ; return e.Min+(r.Location.X-ViewOrigin.Width+fx*r.Width/ViewSize.Width)*q ; }
		double AxeInnerByOuterY( double y , (double Min,double Max) e ) { if( ScreenRect is not Rect r ) return y ; var q = (e.Max-e.Min)/ViewSize.Height ; var fy = (e.Max-y)/q ; return e.Max-(r.Location.Y-ViewOrigin.Height+fy*r.Height/ViewSize.Height)*q ; }
		#endregion

		#region Stepping
		void Coordinates_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.001) ;
		void Coordinates_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.001) ;
		void Coordinates_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.01) ;
		void Coordinates_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.01) ;
		void Coordinates_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(-.1) ;
		void Coordinates_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesMove(+.1) ;
		void Coordinates_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(.001) ;
		void Coordinates_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSet(null) ;
		void Coordinates_CountLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-1) ;
		void Coordinates_CountRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+1) ;
		void Coordinates_CountUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-10) ;
		void Coordinates_CountDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+10) ;
		void Coordinates_CountPageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(-100) ;
		void Coordinates_CountPageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountMove(+100) ;
		void Coordinates_CountHome_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(0) ;
		void Coordinates_CountEnd_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesCountSet(null) ;
		void Coordinates_AtLeft_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(-1) ;
		void Coordinates_AtRight_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeMove(+1) ;
		void Coordinates_AtUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(1) ;
		void Coordinates_AtDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => CoordinatesSizeSet(null) ;
		void CoordinatesMove( double step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(Math.Max(.001*(c.Range.Max-c.Range.Min),(i.Byte+step*(c.Range.Max-c.Range.Min))??c.Range.Max-c.Range.Min),i.Count,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSet( double? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(state*(c.Range.Max-c.Range.Min),i.Count is uint m?state is double s?s==0?i.Count:Math.Min((uint)((c.Range.Max-c.Range.Min)/s),m):1U:null as uint?,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=c.Info.use(i=>(i.Byte,i.Count.use(v=>(uint)Math.Min(i.Byte is double b?(c.Range.Max-c.Range.Min)/b:1,Math.Max(0,(int)v+step))),i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesCountSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Info=(c.Info??(null,null,false)).get(i=>(i.Byte,state,i.Reverse))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeMove( int step ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=c.Size.use(a=>(uint)Math.Max(0,(int)a+step))) ; GridFocusHold(CoordinatesGrid,sel) ; }
		void CoordinatesSizeSet( uint? state ) { var sel = CoordinatesGrid.SelectedItems.Cast<Coordinate>().ToArray() ; sel.Each(c=>c.Size=state) ; GridFocusHold(CoordinatesGrid,sel) ; }
        #endregion

        static async void GridFocusHold( DataGrid grid , IEnumerable<object> sel ) { await Task.Delay(10) ; sel.Each(s=>grid.SelectedItems.Add(s)) ; grid.Focus() ; }

		#region Drifting
		void Source_Left_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-1) ;
		void Source_Right_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+1) ;
		void Source_Up_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<5)) ;
		void Source_Down_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<5)) ;
		void Source_PageUp_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(-(1<<10)) ;
		void Source_PageDown_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftMove(+(1<<10)) ;
		void Source_Home_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(0) ;
		void Source_End_CommandBinding_Executed( object sender, CanExecuteRoutedEventArgs e ) => SourceDriftSet(MainFrameSize.Width) ;
		void SourceDriftMove( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset+=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		void SourceDriftSet( double step ) { var sel = SourcesOffset.SelectedItems.Cast<Aspect>().ToArray() ; sel.Each(s=>s.Offset=step) ; if( GraphTab.IsSelected ) Graph_Draw(this) ; if( MapTab.IsSelected ) Map_Draw(this) ; GridFocusHold(SourcesOffset,sel) ; }
		#endregion

		#region Editing
		void DataGrid_Paste_CommandBinding_Executed( object sender, ExecutedRoutedEventArgs _=null )
		{
			if( sender==AspectAxisGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Axe{Spec=a.At(0+1),Resolvelet=a.At(1+1),Binder=a.At(2+1),Quantlet=a.At(3+1),Asrex=a.At(4+1).Parse(false),Aspectlet=a.At(5+1),Multi=a.At(6+1).Parse(false)}) ;
			if( sender==AspectTraitsGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Aspect.Traitlet{Spec=a.At(0),Lex=a.At(1),Bond=a.At(2),IsPotential=a.At(3).Parse(false)}) ;
			if( sender==AspectsGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Aspect{Spec=a.At(0),Taglet=a.At(1)}) ;
			if( sender==ActionFilterGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Filter.Entry{Filter=a.At(0),Traits=a.At(1),Matrix=a.At(2),Associer=a.At(3),Matter=a.At(4),Query=a.At(5)}) ;
			if( sender==SourceFilterGrid || sender==ActionsFilterFilterGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Filter.Entry{Rex=a.At(0).Parse(false),Filter=a.At(1),Query=a.At(2)}) ;
			if( sender==AspectFilterGrid ) DataGrid_Paste_CommandBinding_Executed(sender,a=>new Filter.Entry{Rex=a.At(0).Parse(false),Filter=a.At(1)}) ;
		}
        static void DataGrid_Paste_CommandBinding_Executed( object sender , Func<string[],object> item )
		{
			if( sender as DataGrid is not DataGrid grid || grid.ItemsSource is not IList items ) return ; var seli = grid.SelectedIndex.nil(i=>i<0)??items.Count ;
			foreach( var line in Clipboard.GetText().SeparateTrim(Environment.NewLine,voids:false,braces:"{}") ) if( line.Separate('\t',braces:"{}") is string[] traits ) item?.Invoke(traits).Set(i=>items.Insert(seli,i)) ;
		}
		void DataGrid_Cut_CommandBinding_Executed( object sender, ExecutedRoutedEventArgs _=null ) { if( sender is not DataGrid grid ) return ; ApplicationCommands.Copy.Execute(null,grid) ; ApplicationCommands.Delete.Execute(null,grid) ; }
		#endregion

		#region Corrections
		void DataGrid_Stop_CommandBinding_Executed( object sender , ExecutedRoutedEventArgs e ) { foreach( Path path in BookGrid.SelectedItems ) path.Corrections?.Clear() ; Redraw() ; }
		void DataGrid_Enter_CommandBinding_Executed( object sender , ExecutedRoutedEventArgs e ) { foreach( Path path in BookGrid.SelectedItems ) path.Corrections?.Commit(e.Parameter.Parse((byte)2)) ; Redraw(true) ; }
		void TabControl_Stop_CommandBinding_Executed( object sender , ExecutedRoutedEventArgs e ) { if( ((sender as DataGrid)?.TemplatedParent as ContentPresenter)?.Content is Path path ) path.Corrections?.Clear() ; }
		void TabControl_Enter_CommandBinding_Executed( object sender , ExecutedRoutedEventArgs e ) { if( ((sender as DataGrid)?.TemplatedParent as ContentPresenter)?.Content is Path path ) path.Corrections?.Commit(e.Parameter.Parse((byte)2)) ; }
		#endregion

		#region Keyboard
		event Action LevelKeyUp , LevelKeyDown ;
		MainExtension.Keylev KeyLevel { get => keyLevel ; set { if( keyLevel==value ) return ; (keyLevel,value)=(value,keyLevel) ; if( keyLevel==default ) LevelKeyUp?.Invoke() ; else if( value==default ) LevelKeyDown?.Invoke() ; } } MainExtension.Keylev keyLevel ;
		void MainFrame_KeyDown( object sender , KeyEventArgs e ) => KeyLevel |= e.Key.Keylevel() ; void MainFrame_KeyUp( object sender , KeyEventArgs e ) => KeyLevel &= ~e.Key.Keylevel() ;
		#endregion
	}
	class Presources : IEnumerable<Pathable>
	{
        readonly IList Origin ; List<Pathable> Base ; readonly DataGrid Grid ; readonly Main Main ;
		public Presources( DataGrid grid , Main main ) { Origin = ( Grid = grid ).SelectedItems ; Main = main ; grid.SelectionChanged += Grid_SelectionChanged ; }
		void Grid_SelectionChanged( object sender , SelectionChangedEventArgs e ) { if( Main.BlockUpdate.Sources ) return ; e.RemovedItems.OfType<Pathable>().Each(p=>Base?.Remove(p)) ; e.AddedItems.OfType<Pathable>().Each(p=>Base?.Add(p)) ; }
		IEnumerable<Pathable> Original => Origin.OfType<Pathable>() ; IEnumerable<Pathable> Basis => Base is List<Pathable> b ? b.Union(Original) : Original ;
		public IEnumerator<Pathable> GetEnumerator() => Basis.GetEnumerator() ; IEnumerator IEnumerable.GetEnumerator() => GetEnumerator() ;
		public int IndexOf( Pathable path ) => Base?.IndexOf(path) is int i && i>=0 ? i : Origin.IndexOf(path) is int j && j>=0 ? j+(Base?.Count??0) : -1 ;
		public void Snapshot() => Base = Basis.ToList() ;
		public void Clean() => Base = null ;
		public void Remove( Pathable path ) { Base?.Remove(path) ; if( Origin.Contains(path) ) Origin.Remove(path) ; else Main.Grid_Coloring(Grid) ; }
		public void Reselect()
		{
			bool recolor = false ; if( Base?.Intersect(Grid.Items.OfType<Pathable>()).ToArray() is IEnumerable<Pathable> join )
			{
				foreach( var path in join.Intersect(Original) ) Base?.Remove(path) ;
				if( join.Except(Original).ToArray() is Pathable[] exce && exce.Length>0 ) foreach( var path in exce ) Origin.Add(path) ;
				else recolor = true ;
			}
			if( recolor ) Main.Grid_Coloring(Grid) ;
		}
	}
	static class MainExtension
	{
		public static IEnumerable<Objective> Issue<Objective>( this IEnumerable<Objective> items , params (Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query)[] refine ) => items==null ? null : refine?.Length>0 ? refine?.Length>1 ? refine.SelectMany(items.Issue).Distinct() : items.Issue(refine[0]) : items ;
		public static IEnumerable<Objective> Issue<Objective>( this IEnumerable<Objective> items , (Func<Objective,bool> Filter,Func<IEnumerable<Objective>,IEnumerable<Objective>> Query) refine ) => items==null ? null : refine.Query==null ? refine.Filter==null ? items : items.Where(refine.Filter) : refine.Filter==null ? refine.Query(items) : refine.Query(items.Where(refine.Filter)) ;
		public static IEnumerable<Aspect> Reprojection( this IList<Aspect> sources ) => sources.Each((s,a,i)=>a.Sources=s.Skip(i).Concat(s.Take(i)).ToArray()) ;
		public static double? By( this double value , (double Min,double Max) extent , bool positive = true ) => (positive?value-extent.Min:extent.Max-value)/(extent.Max-extent.Min).nil() ;
		public static (double Width,double Height) Margin( this (double Width,double Height) frame , (double Width,double Height) margin ) => (frame.Width-2*margin.Width,frame.Height-2*margin.Height) ;
		public static string Link( this string detail , int at ) { at = detail.IndexOf(at,Uri.SchemeDelimiter) ; if( at<0 ) return null ; while( at>0 && detail[at-1].IsSymbolChar() ) --at ; return detail.Substring(at).LeftFrom(true,' ','\n') ; }
		public static void Start( this string link , Func<Uri,string> extra ) { var uri = link.Uri() ; if( extra(uri) is string app ) Process.Start( app , link ) ; else Process.Start( link ) ; }
		internal static Keylev Keylevel( this Key key ) => key switch { Key.LeftCtrl or Key.RightCtrl => Keylev.Ctrl , Key.LeftAlt or Key.RightAlt => Keylev.Alt , Key.LeftShift or Key.RightShift => Keylev.Shift , _ => default } ;
		[Flags] internal enum Keylev { Shift = 1 , Ctrl = 2 , Alt = 4 }
		internal static ( IList adds , IList rems ) SelectionsItems( this IList<SelectionChangedEventArgs> e )
		{
			if( e?.Count<=0 ) return default ;
			List<object> add = new(e[0].AddedItems.OfType<object>()) , rem = new(e[0].RemovedItems.OfType<object>()) ;
			for( var i=0 ; i<e.Count ; ++i ) { add.AddRange(e[i].AddedItems.OfType<object>()) ; rem.AddRange(e[i].RemovedItems.OfType<object>()) ; e[i].AddedItems.Each(r=>rem.Remove(r)) ; e[i].RemovedItems.Each(r=>add.Remove(r)) ; }
			return (add,rem) ;
		}
	}
}
